### P1316 丢瓶盖

算法标签: **二分答案**, **贪心**
其他标签: **高性能**


#### Description

题目大意： 给定 x 轴上 $n$ 个点，从中选择 $m$ 个点，使得这 $m$ 个点之间的最近距离 最大。

其实就是从 $n$ 个点中找 $m$ 个点的最近距离的上界。

#### Analysis

这一题与 数列分段（P1182）是同样类型的题目。 数列分段求的是 分段和最大值的最小： 找到 这个最大值的下界， 可以通过二分查找找到。

这一题求的是 若干点之间距离最小值的上界。 也可以通过二分查找。

这种题目综合考察 **贪心** 和 **二分查找**。

首先看怎么找这 $m$ 个点： 限定 一个最小距离 $d$， 选择第一个点，然后依次选择一个距离刚好超过 $d$ 的点， 如此看能选择多少点。

这是一种贪心选择算法， 它解决的最优问题是： 给定一个最小间距 $d$，可以选择最多多少点？使得这些点的间距都不小于 $d$。

这种贪心选择算法可以得到最优解比较容易证明。令 $S$ 是贪心解，贪心解的第一个点，是所有点的第一个点 $p_1$。贪心选择的是下一个点 $p' - p_1 \geq d$。 如果有一个最优解 $Z$。

- 第一个点不是 $p_1$， 可以将 $Z$ 的第一个点换成 $p_1$ ，而不改变解的约束（所有点间距 $\geq d$），不改变解的大小，仍是一个最优解。
- 某一个最优解第一个点是$p_1$， 下一个点不是 $p'$， 那么也只会比 $p'$ 大， 设为 $p'' > p'$， 将这个点与$p'$ 交换，也不会改变解的约束，不会改变解的大小，仍然是一个最优解。
- $S$ 和 $Z$ 具有相同的最优子结构， 所以 $S$ 也是一个最优解。 

证明了贪心选择可以在一个间距不小于 $d$ 的约束下，找到最多数量的点。 反过来问，限定选择的点的数量 $m$ ，如何找到 $d$ 的上界： 即超过 $d$ 一点点（1），就不能选择 $m$ 个点。

一种朴素的（naive，怂，谨慎）的思想是， 每次增加一点点 $d$，去找最多数量的点，看能不能找到 $m$ 个，如果能找多于 $m$ 个或者等于 $m$ 个，继续增加一点点 $d$，直到找到的数量刚好小于 $m$ 个。 这个 $d$ 就是最小间距的上界。

二分法就很快了，划定一个范围找 $d$， 先扯一大步（步子大了那啥），在中间找，如果可选择的数量小于 $m$ 个，说明步子大了，退半步在左边区间继续查找； 如果可选择数量大于等于 $m$ 个，说明还没到 $d$ 的上界， 继续扯一大 **半** 步找。

最后总能收缩到 $d$ 的上界。

所用时间复杂度为 二分查找次数 乘以 每次判断的时间： $O(N \log(Z))$ 其中 $Z$ 是数的大小量级。


#### 二分查找注意事项

二分查找的选择，有一个需要注意的地方。 在 `[left, right]` 范围查找

令 `mid = (left + right) / 2` 会有一个问题。

- 如果 `mid` 可能是问题的解，并且问题的解落在 `[mid, right]` 范围，那么继续接下来在 `[mid, right]` 内查找。否则在 `[left, mid - 1]` 中查找。
- 如果 `mid = (left + right) / 2` ，当  `left + 1 = right` 的时候， 会陷入一个无限死循环： `mid` 总是等于 `left`。 


有很多种解决方法，一种方法是令 `mid = (left + right + 1) / 2`， `mid` 总是更靠近 `right`，这样，当 `left + 1 = right` 的时候 ，`mid = right`， 如果 `mid = right` 满足，则 `mid = right` 就是答案； 否则就退到  `[left, mid - 1]`  即 `[left, left]` 区间， `left` 就是答案。


这是找一个上界需要注意的地方。 在找一个下界的时候，如果当前 `mid` 不满足，直接 `[left, mid]` 或者 `[mid + 1, right]` 找， `mid = (left + right) / 2` 不会有什么问题。

所以二分查找的 `mid` 选择也很讲究，视找上下界的情况决定。



#### [Code](../cpp/p1316.cpp) 

