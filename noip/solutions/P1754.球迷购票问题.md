### P1754 球迷购票问题

算法标签: **动态规划,动规,dp**, **数论,数学**
其他标签: **高性能**


#### Description

卖门票，门票 50元。 有 $n$ 个拿50的， 有 $n$ 个拿100的。售票员开始没有钱，只有通过收 50的， 来找开拿 100的。

问如何排列，售票员不至于手上没钱找。 这种排列方式有多少个？（不区分人，只区分 50， 100）

#### Analysis

也是费了一点小功夫。

这种题目，可以观察一些样例来得到规律。

假设 `A` 是 50块， `B` 是 100块。

例如 `AABB` 这种， 现在考虑 `B` 排在最后一位，前面是 2个 `A` 和 1个 `B` 的所有可能排列情况， 有 2种；

考虑 `A` 排在最后一位，前面是 1 个 `A` 和 2个 `B` 的情况， 因为总共只有 1张50， 无法找开 2个人的 100。 所以这是不可能的。 一般化就是，当 $i < j$ 的时候， 不存在可能的排列情况。

对一般的 `dp(i, j)` 问题，表示 `i` 个人拿50， `j` 个人拿 100的所有可能情况。 可以变成： 最后一个拿 50，或者是 100； 最后连续两个50， 最后连续三个50 ....

这就很像 完全背包的货币组合问题形式。

$dp(i, j) = dp(i, j - 1) + dp(i - 1, j)$ 

唯一的限制是： 当 $i < j$ 的时候，$dp(i, j) = 0$

最后代码真是超简单。。。

```cpp

#define MAX_N 21

int main()
{
    int n, i, j;
    scanf("%d", &n);

    long long dp[MAX_N] = {0};
    dp[0] = 1;
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= i; ++j)
            dp[j] = dp[j] + dp[j - 1];

    printf("%lld", dp[n]);

    return 0;
}
```


#### [Code](../cpp/p1754.cpp) 

