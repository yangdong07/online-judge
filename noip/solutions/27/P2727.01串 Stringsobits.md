
### P2727 01串 Stringsobits

算法标签: **动态规划,动规,dp**, **搜索**
其他标签: **USACO**

#### Description


#### Analysis

这题很有意思。

如果题目换成问 $n$ 位二进制数字，1的个数不超过 $l$的 有多少个。 那么就是一个非常普通的动态规划问题。

令 $dp(n, l)$ 表示这个数字，动规方程是这样子的：

- $dp(0, l) = dp(n, 0) = 1$
- $dp(n, l) = dp(n - 1, l) + dp(n - 1, l - 1)$ 

动规方程中， 第一项是 当首位为 $0$ 时，符合条件的二进制数字的个数； 第二项是 首位为 $1$ 时，符合条件的二进制数字的个数。

所以很自然的想到 如果要找第 $k$ 个数字， 如果 $k \leq dp(n - 1, l)$ 的话，首位为 0， 在剩下 $n - 1$ 位中找第 $k$ 个数字； 如果 $k > dp(n - 1, l)$， 在剩下的 $n-1$ 位中找第 $k - dp(n - 1, l)$ 个数字。


#### WA原因

以为 $dp(n, l)$ 只在 $n \geq l$ 有值。 实际上当 $n < l$ 的时候，$dp(n, l) = 2^n$， 这也是有效的。

比如当 $k = 1$ 时，答案是 $0000$，但是在递归中会不断找 $dp(n - 1, l)$， $n$ 会不断减小，直到减小到0， 就开始输出1了，这是不对的。



#### [Code](../../cpp/27/p2727.cpp)


