### P1282 多米诺骨牌

算法标签: **动态规划,动规,dp**, **枚举,暴力**, **背包**


#### Description

#### Analysis

这一题做了2天。 总算是搞定了。

最开始一点思路都没有，看了题解知道可以用背包的动规思想。

犯了一些错误：

1. 因为背包的大小不是确切的大小：需要逼近总容量 $W$ ，最后小一点和大一点都没关系，只要是最接近的值就行了。

并且背包是求最大价值； 这里需要最少步数。所以一开始我没有想到背包。

2. 数字非常简单。这个问题实际上可以转成另一个问题： 有 1、2、3、4、5 重的砝码若干个，放在天平的两端， 开始的时候是不平衡的： 调整天平两边的砝码，使得天平达到所能达到的最平衡的状态，并且要求移动砝码的次数最小。 即问最少多少次可以使天平足够平衡。

直觉上看，这个问题似乎很简单：

- 如果两端极不平衡，则将重的那端的最重的砝码尽多的放到轻的那端，使得天平差不多平衡，这是粗调；
- 然后再微调天平，用最少的步数去实现最小的重量差。

因为数字范围很小，所以看上去能在线性时间内解决。（后来发现确实是可以的，确实是因为这个数字范围太小了）

尝试了很多种方法去最简单的解决这个问题，但是都失败了。

3. 这个问题实际上是一个简单的 **整数线性规划（LIP）** 问题。 这是个 NP-hard 问题，没有通用的多项式时间的算法

像这种简单的 LIP 问题，用背包的动规思路都还可以解决。

所以最大的教训是这个：**不管以何种方式，何种思想，先解决问题，第二步或者最后一步才是优化这个解。 优化的过程不能建立在空中楼阁上。**

最后我还是按照背包的动规方法去写状态方程， 然后用 “粗调” “细调” 的方式进行了一下优化。感觉还是很不错的。 粗调是按照直觉使用的， 粗调到一个 `[target + RANGE, target - RANGE]` 范围之后，再进行微调。这个 `RANGE` 范围也是待验证的。 最后的时间复杂度是 $O(N R)$， $R$ 就是动规状态范围。可以认为是常数时间。

说了这么些废话，还是给出动态规划状态方程。

$$dp(n, w) = \min(dp(n-1, w), dp(n-1, w - w_n) + 1)$$

长得很像背包的动规方程，但是它找的是 $n$ 个骨牌，差值变成 $w$ 的最少翻转次数。

这里面还有几个小问题：

1. 差值有可能变成负值， 但是数组索引不能是负数。
2. 起始的状态 $w$ 是什么？ 目标状态的 $w$ 是什么？


我们假设需要消掉的不平衡量是 `target`，目标是通过翻转使得最后的不平衡量（差值）最小。原来差值为 `5` 的骨牌，翻转后，会消去 `10` 的差值，原来差值为 `-4` 的骨牌，翻转后，会增加 `8` 的差值。但是这样很难写状态方程： 因为目标值在 `0` 附近， 起始值可能在一个很远的地方，也不一定是正的。不好确定 $w$ 的位置。

或者换一个角度思考：我们假设初始状态为 $w = 0$， 目标是组成一些差值来抵消 `target` 。那么选择一个差值为 `5` 的骨牌翻转，可以抵消掉 `10` 。选择一个差值为 `-4` 的骨牌，可以抵消 `-8` 。

因此可以将每个骨牌直接记录 权重 `w[i] = x * 2`， `x` 即骨牌当前的差值，`*2` 表示翻转可以抵消的差值。 我们的最终目的是凑出 `target` 的差值。 所以起始值是 $0$， 目标值是 `target` 附近（因为不确定是否能精确到达 `target`）。

如果 `target` 开始的时候是一个负值，那么将所有骨牌全部颠倒一下， 将 `target` 翻转。其实就相当于将天平左右两端调个个，不影响结果。

这样： 从 0 ~ `target` 始终在正范围内。


关于粗调： 我需要保证只在 `[target - RANGE, target + RANGE]` 的地方进行动规状态累计就行了，

在进入这个区间之前，如果离 `target - RANGE` 还有一段距离，那么就用贪心策略快速跳入这个区间，然后计算。

```cpp

using namespace std;

bool greater(int a, int b) { return a > b; }

int main()
{   
    const int MAX_N = 1001;
    const int RANGE = 50;
    const int MAX_INT = 1 << 30;

    int n, i, j;
    int w[MAX_N];

    scanf("%d", &n);
    int t1, t2;
    int target = 0;
    for (i = 0, j = 0; i < n; ++i)
    {
        scanf("%d %d", &t1, &t2);
        if (t1 != t2)
            w[j++] = (t1 - t2) * 2;
        target += (t1 - t2);
    }
    n = j;
    if (target < 0)
    {
        target = -target;
        for (i = 0; i < n; ++i)
            w[i] = -w[i];
    }
    sort(w, w + n, greater);

    int dp[RANGE * 3];
    for (i = 0; i < RANGE * 3; ++i)
        dp[i] = MAX_INT;

    // greedy jump into  [target - RANGE, target + RANGE];
    int step = 0;
    for (i = 0; i < n && target >= RANGE && w[i] > 0; ++i, ++step)
        target -= w[i];
    dp[0] = step;

    for (; i < n && w[i] > 0; ++i)
    {
        for (j = target + RANGE; j >= w[i]; --j)
            dp[j] = min(dp[j], dp[j - w[i]] + 1);
    }

    for (; i < n; ++i)
    {
        for (j = 0; j <= target + RANGE - w[i]; ++j)
            dp[j] = min(dp[j], dp[j - w[i]] + 1);
    }

    for (i = 0; i < RANGE; ++i)
    {
        if (dp[target + i] != MAX_INT || dp[target - i] != MAX_INT)
        {
            printf("%d", min(dp[target + i], dp[target - i]));
            return 0;
        }
    }
    // printf("%d", dp[target]);

    return 0;
}
```


注意上面代码的一些策略：

1. 先按权值从大到小，从正到负的情况排序，然后快速跳入区间
2. 使用一维DP，对于正权值，按照常规背包，从后到前更新状态； 对于负权值，则从前到后更新状态。
3. 最后找 target **附近** 的最优解， 最优解不一定在 target 上。


#### [Code](../cpp/p1282.cpp) 

