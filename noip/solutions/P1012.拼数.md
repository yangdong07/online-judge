### P1012 拼数

算法标签: **字符串**, **排序**
其他标签: **NOIp提高组**, **1998**


#### Description

设有 $n$ 个正整数 ($n \leq 20$) ，将它们联接成一排，组成一个最大的多位整数。

例如： $n=3$ 时， 3 个整数 $13$ , $312$, $343$ 联接成的最大整数为： $3433123$

例如： $n=4$ 时， 4 个整数 $7$ , $13$, $4$, $246$ 联接成的最大整数为： $7424613$

#### Analysis

这题虽然抄了题解，确迟迟没有提交。 是因为我还没有证明。

```cpp
string a[21];

bool cmp(string a, string b)
{
    return a + b > b + a;
}

int main()
{
    int n, i;
    cin >> n;
    for (i = 0; i < n; i++)
        cin >> a[i];
    sort(a, a + n, cmp);
    for (i = 0; i < n; i++)
        cout << a[i];
}
```

排序的比较方法用 `a + b > b + a` 就可以了，非常简单。

为什么这样做是有效果的？ 我试图证明这一点。

首先需要证明，这种不等式符合 **传递律**， 即：如果 $ab > ba, bc > cb$ ，可以得到 $ac > ca$，这里 $a, b, c$ 都是字符串， 操作是拼接操作。

一开始我试图用逐个字符比较的方式来证明这一点，后来发现挺麻烦的。 其实可以观察到一个现象：如果 $ab > ba$

则 ： $aabb > abab > baba > bbaa$， 并且任意的 $a\dots ab\dots b > b \dots b a \dots a$， 注意 $a, b$ 数量不变，仅仅位置翻转。

因此我们有： $b\dots bc\dots c > c \dots c b \dots b$

如果取足够的数量， 再截取每个字符串长度的最小公倍数长度， 则总是有 $a \dots a > b \dots b > c \dots c$ 成立。（否则全部长度就不成立）。

反证也是很容易的： 如果 $ac \leq ca$， 则会得出 $a\dots a \leq c \dots c$ 的结论， 这是矛盾的。所以 如果有 $a + b > b + a$, $b + c > c + b$， 则有 $a + c > c + a$。 这里 $+$ 是拼接操作。

其次需要证明： **在 $a,b,c,d,e,f,g\dots$ 这些字符串已经按上述不等式关系排序，即 $ab > ba ...$，则所有字符串拼接的方式中， 以 $a$ 开头是最大的**。

这个证明也就很简单： 比如假设有一个最大的拼接方式不是以 $a$ 开头， 例如 $efgabcd$， 那么可以看出 $efgabcd < efagbcd < eafgbcd < aefgbcd$ ，总是可以通过冒泡的方式，把 $a$ 放到前面来。

**所以如果所有字符串按上述方式进行了排序， 则最后按顺序拼接的字符串总是最大的**


如果理解了这个不等式，以及这种冒泡交换方式， 最后一个结论可以直接看出来， 不用费这么多事情。

2018-08-25 12:59:15 补充：

做了 P1417 回过头来看这题实在太简单了。 其实理解一下： 在一个已经拼接好的字符串中，对调相邻两个字符 `ab` 的位置变成 `ba`，如果 `ab` > `ba` ，那么对调后就不是最大字典序的； 如果 `ba > ab`，那么对调后就可以变大。

所以说，理解最后一点就可以了。但是传递律的证明可以帮助加深理解。

#### [Code](../cpp/p1012.cpp)
