### P1219 八皇后

算法标签: **位运算,按位**, **搜索**, **深度优先搜索,DFS**
其他标签: **USACO**, **高性能**


#### Description

在 $n \times n$ 的棋盘上放 $n$ 个皇后，使得他们互相不能攻击。

皇后的攻击范围为 同行、同列 和同对角线。  求出所有解。

#### Analysis

八皇后问题是比较典型的回溯法问题。

想象一个搜索树， 从第一个皇后开始，选择一个放皇后的位置，有 64 种选择，接下来第二个皇后， 也要搜索64个位置。 总共有 8 层。 一个完整的搜索树，总共有 $ 64^8 \sim 10^{14}$ 个叶子结点。

实际上每行只能放一个皇后，那么问题就大大简化： 从第一行开始，选择一个皇后的位置，有 8 个位置； 第二行也有 8 个位置； 如此，一个完整的搜索树是 $8^8 = 16777216 $ 个叶子结点。

在搜索过程中也没必要一搜到底。 如果第二行和第一行的皇后发生冲突，那么这个搜索分支就可以丢掉。抹去第二行的状态， 回溯到第一行，继续其他位置的搜索。

关于状态的判断和保存： 对每一行的皇后位置选择， 都要判断与之前行的皇后是否发生冲突。 这个判断如果是 $O(n)$ 的，那么也不是很理想。最好将其变成 $O(1)$。

- 对于行来说，每 i 层搜索第 i 行的皇后位置。不用检查行冲突。
- 对于列来说， 总共 $n$ 列，准备一个数组 `p`， `p[j]` 表示 第 j 列的状态，如果有皇后占领了这一列，那么 `p[j] = 1`，否则 `p[j] = 0`
- 对于主对角线，可以观察到每条对角线上的 `j - i` 都是相同的，总共有 `n * 2 - 1` 条对角线， 那么用 `x1[j - i + n]`，表示 `j - i` 对角线的状态。
- 对于副对角线， 可以观察到每条对角线上的`i + j` 都是相同的，总共 `n * 2 - 1` 条对角线，那么用 `x2[i + j]` 表示 `i + j`  对角线的状态。

```cpp
int q[100], p[100], x1[100], x2[100];

int n;        // 棋盘大小 n * n;
int s = 0;    // 解的数量

void queen_search(int i)
{
    if (i == n)
    {
        s++;
        return;
    }
    else
    {
        for (int j = 0; j < n; j++)
        {
            if (!p[j] && !x1[j - i + n] && !x2[i + j])
            {
                q[i] = j;
                p[j] = x1[j - i + n] = x2[i + j] = 1;
                queen_search(i + 1);
                p[j] = x1[j - i + n] = x2[i + j] = 0;
            }
        }
    }
}
```

注意回溯法一个关键特征是，搜索是深度优先搜索，在搜索的时候，**状态** 是不断累积的。如果一个分支可以提前中止，那么需要将 **状态回溯** 一下，再进入其他分支搜索。

#### [Code](../cpp/p1219.cpp)
