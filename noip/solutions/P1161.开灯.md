### P1161 开灯

算法标签: **桶排**, **模拟**, **进制**


#### Description

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4, \dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数， $a$，$t$ （ $a$ 为实数， $t$ 为正整数）。将编号为 $[a]$，$[2 \times a]$，$[3 \times a]$，...， $[t \times a]$ 的灯的开关各按一次。其中 $[k]$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？

（说是无限长，实际路灯数量不会超过 $2 \times 10^9 < 2^{32}$）

#### Analysis

这道题很棒。 此题的关键是这个信息： **最后只有一盏灯是开着的**。

如果按照常规思路： 准备一个 $2^{32}$ 长度（足够长）的数组，每个位置有 0/1 两个状态， 每次操作先计算索引，然后按照索引位进行 `a[i] ^= 1` 操作就可以了。这里 `^= 1` 用途就是取反。

时间复杂度上是最优，但是使用的空间太多了： 即使用 $2^{32}$ 个bit， 也有 $2^{29}$ 个 byte ， 536MB 空间。

其实关键还是 **最后只有一盏灯是开着的** 这个信息。

先看一下大佬的代码（不错，就是抄过来的！）

```cpp
int main()
{
    int n, t, lamps=0;
    double a;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
    {
        scanf("%lf %d", &a, &t);
        for (int j = 1; j <= t; ++j)
            lamps ^= int(a * j);
    }
    printf("%d", lamps);
}
```

看到了什么：**每次只是对索引位置做一次异或`^`操作** 。 为什么这样做有效？

可以这样理解： 每次开关灯，都记录一次位置。但是如果对同一个位置进行了偶数次操作，实际上等于没有操作，可以取消记录。

用异或运算就可以做到这一点。 异或运算满足 交换律、结合律。并且有以下性质：

- `a ^ 0 = a`， 保持不变
- `a ^ a = 0`， 相同为0
- `x ^ a ^ a = x ^ 0 = x`， 所以任意两次操作，都会清除 `a` 的影响。

所以说，如果 **最后只有一盏灯亮着** ，那么用 `lamps ^= int(a * j)` 折腾半天，最后只会留下唯一的一个位置索引，就是最后答案。

延伸的问题是： 如果没有这个条件， 还能不能用这个方法？ 答案是 **不能** ：

$2^{32}$ 个路灯的所有状态是  $2^{2^{32}}$ 个 ，远不是一个 int 型的数能够表示的。


#### [Code](../cpp/p1161.cpp)
