### P1917 三子棋II

算法标签: **模拟**


#### Description

#### Analysis

这个问题琢磨了很长时间。 总算可以一定程度上的收工了。

连带三子棋 I 的问题。

三子棋I问题很好判断： 只需要判断棋盘上的状态就可以了： 遍历每个位置： 纵向、横向、对角如果三个字符相同，则获胜。 使用一个 字符串表示会非常方便。

三子棋II的问题，就涉及到 博弈了。 它的问题是给定一个局面， 问是否必胜、必败，还是和局。

因为三子棋的局面状态很简单：

- 一个棋子 `O` 的局面有 $C^{1}_{9}$ 个
- 两个棋子 `OX` 的局面有 $C^{1}_{9} \times C^{1}_{8}$ 个
- $2k$ 个棋子 `OX` 的局面有 $C^{k}_{9} \times C^{k}_{9 - k}$ 个
- $2k + 1$ 个棋子 的局面有 $C^{k + 1}_{9} \times C^{k}_{9 - k - 1}$ 个

全部状态也只有：  $3^9 = 19683$ 不到 2w个状态。

现在的问题是，**如何构造博弈树** 。

对某一个局面，下一步的决策肯定是让自己的收益最大。 **如何定义这个最大收益**：

- 如果在这一步，在剩余的放子位置，某个位置上，可以赢得比赛（三子连线），那么选择这个位置，收益最大，可以记成 $+ \infty$ ，当然在这里除了胜负手、平局，没有别的状态， 所以收益记成 1，足够了。 这是必胜局。
- 如果无法在这一手定胜负，则遍历每个位置落子，下一步轮到对手。 对手也会考虑到自己最优的一步，即收益最大的一步。 **对手的收益，即为自己的损失**。
    - 如果对手收益为 1， 对手的必胜局。 则落子位置的收益为 -1 ，价值最小。
    - 如果对手收益为 -1，对手的必败局。 则落子位置的收益 为 1，价值最大。
    - 如果对手收益为 0， 说明是平局。
- 遍历所有位置，找出最大收益的位置
    - 如果所有位置最大收益为 1， 则说明可必胜。
    - 如果所有位置最大收益为 0， 则说明最多平局
    - 如果所有位置最大收益为 -1， 则说明，无论下在哪个地方，对方总是能赢， 则己方为必败局。

这样就可以构造一个博弈树，用来计算局面是否必胜、必败，还是和局。（当然也可以用来做决策，对当前局面计算一个收益最高的位置）。

```cpp
int play_board(string b, int step)
{
    int state = 0, i;
    char c = step & 1 ? 'O' : 'X';
    bool gameover = true;

    // printf("%d\n", step);
    // print_board(b);

    for (i = 0; i < 9; ++i)
    {
        if (b[i] == '-')
        {
            gameover = false;
            b[i] = c; // play O/X on i;
            state = check_board(b, i);
            b[i] = '-';

            if (state) return state;
        }
    }
    if (gameover) return 0;  // tie

    state = -2;
    for (i = 0; i < 9; ++i)
    {
        if (b[i] == '-')
        {
            b[i] = c; // play O/X on i;
            state = max(state, - play_board(b, step + 1));
            b[i] = '-';
        }
    }
    // printf("%d\n", step);
    // print_board(b);
    return state;
}
```

先遍历一遍落子位置； 然后再由对手决策。


这种棋类游戏，可以总结出来一个关键点是： **根据局面决定收益最大的一步**。 互相博弈即可。

这里有胜负手。所以在每一步先判断一下是否有一步直接取胜。

因为只有胜负价值，没有落子局势价值，所以收益判断比较容易。

类似的棋类游戏如象棋，有胜负手，同时因为棋子的子力也是一种价值。还要综合考虑吃子的收益。 一般车的子力最强，用一个炮换一个车的价值就很大。


#### [Code](../cpp/p1917.cpp)
