
### P1460 健康的荷斯坦奶牛 Healthy Holsteins

算法标签: **剪枝**, **深搜 + ID**
其他标签: **USACO**

#### Description


#### Analysis

这题很有意思。找到一种最少的组合方案，看似像一个 广搜，实际上可以通过 **限制深度的深搜** 来解决。 其时间复杂度与广搜是差不多的，但是空间复杂度就很低，并且也特别好理解。

在 USACO 的搜索技巧（第1.5节）中提到过。这个地方用起来应该是最合适的。

整个目标就是找一种满足需求的最少组合方案，并且还要输出字典序最小的。 广搜和深搜的综合体： 广搜找最小； 深搜找最小字典序。 DFS + ID 就很好解决。

解题的过程中，也在思考搜索的意义（其实我并不是很擅长搜索）。

每个节点代表着什么？ 每个路径代表着什么？ 起点是什么？搜索时的状态有没有被破坏？需不需要回溯？ 答案在路径上，还是在叶子节点上？？ 有很多问题。

像这道题，一开始就不是很清楚起点是什么。

这道题：

- 如果不限制搜索深度，答案可能在内部节点上，可以提前终止； 如果限制了搜索深度，则答案肯定在叶子节点上。
- 在叶子节点检查是否为可行解，并终止搜索返回。（如果答案在内部结点上，就需要每次都检查）
- 因为每多选一个饲料，都要累积饲料的供应量，所以这算是一种破坏状态，需要使用回溯。
- 起点从 0开始， 如果高度（深度） 为1， 说明只选择一种饲料。 那么叶子节点就是只选择一种饲料的情况。

如果把改变状态理解成路径。 那么这种路径最好写在父节点中，准备好子节点的状态，进入子节点继续搜索。返回时回溯状态（相当于路径回溯）也很方便。

也可以在子节点改变状态，但是回溯过程就得让子节点完成。


搜索的时候，需要深刻理解： 每个dfs调用都对应着进入了一个节点。在节点中对 dfs 的递归调用，意味着一个分支。


还有一个问题是： 如何通过搜索来产生各种组合？  这是一个好问题。。

因为不擅长搜索。 这方面还需要加强练习。


#### [Code](../../cpp/14/p1460.cpp)


