
### P1467 循环数 Runaround Numbers

算法标签: **搜索**
其他标签: **USACO**

#### Description


#### Analysis

这题总算过了。感觉自己饶了个大弯路。

题目要求找出第一个大于 给定数 $M$ 的循环数。 

循环数的数字不能为0， 也不能重复。 其定义是 从第一个数字 $x$ 开始，访问右数第 $x$ 个数（超出则从头循环）。重复上面过程，可以访问到所有的数，并最后回到第一个数字，完成循环。

我的思路是模拟这个循环过程的同时 ，dfs 搜索。

每个dfs函数主要做一件事情： 找到一个当前位置的可用数 $x$，然后将指针移动到 `(cur + x) % len`，深度加一，继续搜索。

- 如果搜索深度已经到了指定长度，则检查是否循环数，既指针是否返回到了起点 0。
- 如果还没有到指定深度， 但是这个位置已经有数占用了，停止这个分支的搜索。
- 如果这个位置还没有被占用， 对每个当前位置的可用数 $x$， 赋值并分支搜索。

搜索过程中注意回溯。

这种方法很直观，但是踩了一堆坑。

1. 题目要求第一个大于 给定数 $M$ 的循环数。

我开始的策略是，把 $M$ 这个数，拆分，然后在搜索的过程中，每个可用数都不小于对应数位的数字。

感觉没毛病，实际上挺2。 这样 给定 199998 基本上就找不到数了。

2. 搜索的指针位置并不是 1，2，3，4，5，是跳跃的。 所以第一个搜到的数并不一定是最小的。。。。。

比如 第一个大于 81361 的循环数是 81362， 但是我找出来第一个数是 86312。

为什么？ 因为第0个数字是8， 下一个是第4个数字，这里是1，确实是当前位最小的，但不是整个数字最小的。。。

主要是这两个坑，最后还不小心踩了个 无符号长整型的坑。。。

最后的方法是，把这个位数 $n$ 的所有循环数都找一遍， 然后输出第一个大于 给定数的。。。。。


其实如果一开始用 1~9 数字的排列找，最多也就是 $9! = 362880$ 个点。暴搜检查就可以了。出错率还低。


#### [Code](../../cpp/14/p1467.cpp)


