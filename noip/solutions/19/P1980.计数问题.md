### P1980 计数问题

算法标签: **字符串**, **模拟**
其他标签: **NOIp普及组**, **2013**, **高性能**


#### Description

#### Analysis

这种计数题，实在懒得再去分析了。 直接暴力解掉好了。

```cpp
int solve1(int n, int d)
{
    int t, count = 0;
    for (int i = 1; i <= n; ++i)
    {
        t = i;
        while (t)
        {
            if (t % 10 == d)
                ++count;
            t /= 10;
        }
    }
    return count;
}
```

#### Solution2

强迫症犯了。 又花了点时间分析了一下。（参考了题解）

一种非常好的计数方式是这样子的， 比如 728， 找 7 出现的次数，这样看：

- 7 在 个位出现在 `7, 17, 27, ..., 727` 有 73 个， 这个 73怎么得来？  `728 / 10 = 72`， 再因为 个位的 `8 > 7`，所以这里多了 1个 ，总共有 73个
- 7 在 十位出现在 `70~79, 170~179, ..., 670~679`， 有 70 个。 这个 70 怎么算出来的？  `728 / 100 = 7`。 因为 十位上的 `2 < 7`。 所以没有多出来。但是注意这里有几种情况：
    - `x < d`， 计数不变
    - `x > d`， 实际上会多出来一组。 比如 788 会多出来 `770~779` 这一组， 所以多 **10** 个。
    - `x == d`， 比如 778，会多出来 `770 ~ 778` 9 个 `9 = 8 + 1 = n % 10 + 1`
- 7 在百位上出现在 `700 ~ 728`，只有 29 个，实际上这是上面 `x == d` 情况的计算： `29 = n % 100 + 1`

归纳一下就会发现这个规律：

假设 `n` 在 `m = 1, 10, 100, 1000 ...` 位上的数字为

- `x = n / m % 10`，
- 左边的部分为 `a = n / m / 10`，
- 右边的部分为 `b = n % m`

则在 `m` 位上出现 `d` 的次数 为 `a * m` 个。

- `x > d`， 需要补充 `m` 个
- `x == d`， 需要补充 `b + 1` 个
- `x < d`，不需要补充。

以上没有考虑 `d == 0` 的情况。 这个情况比较特殊。

在计算 `m` 位上出现 `d` 的次数时，如果 `d` 是 0， 则不可能有 `00, 10, 20, 30` 这种情况。 所以初始计数是 `(a - 1) * m`。

但是后面的补充计数条件是一样的。


```cpp
int solve2(int n, int d)
{
    int t;
    int a, x, b;  //  `axb`, a left, x digit, b right
    int m;  // 1, 10, 100....
    int count = 0;

    for (m = 1; t; m *= 10)
    {
        a = n / m / 10;
        x = n / m % 10;
        b = n % m;

        count += (a - (d == 0)) * m;

        if (x > d)
            count += m;
        else if (x == d)
            count += (b + 1);
    }

    return count;
}
```



#### [Code](../cpp/p1980.cpp)
