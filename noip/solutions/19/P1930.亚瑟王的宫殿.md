
### P1930 亚瑟王的宫殿

算法标签: **广度优先搜索,BFS**, **搜索**, **最短路**, **枚举,暴力**
其他标签: **USACO**, **高性能**

#### Description


#### Analysis

这一题也是个大题。。主要考察 BFS，以及对图形的一些抽象。

这一题如果能够想到用一个四维数组保存任意点对的 **最短路**， 就算解决了一半问题。

这里的最短路是指 骑士（马）从一个点到另一个点的最少步数。因为是无权图，可以用 $|V|$ 次 BFS 解决这个问题。因为无权图单源最短路的计算时间只需要 $O(V + E)$， 这是个稀疏图，所以单次 BFS 时间为 $O(V)$， 总时间复杂度为 $O(V^2)$。

然后对每个棋盘上的点，假设为集结点，进行 $|V|$ 次模拟循环：

现在来看国王的移动。一开始我有点想偏了，我甚至想过是否能建立一个以国王为中心的力场模型。。。23333

其实国王的思路也非常简单：在国王附近找一个点，看看派遣一个骑士过来，在这个点接国王之后，能不能节省总的步数。

- 独自旅行的总步数 = 所有骑士到集结点的步数 + 国王独自到集结点的步数
- 捎上国王的总步数 = 某个骑士 $k$ 到某个点 $z$ 捎上国王的步数 + 骑士从 $z$ 点赶往集结点的步数 + 国王到达 $z$ 点的步数。

这里需要 进行 $KZ$ 次查找，找到总步数的一个最小值。如果骑士数量 $K = V$，查找的点 $Z = V$，最后的算法时间复杂度为 $O(V^3)$， 也还好。 不过 $V$ 的量级在 $10^3$， $O(V^3)$ 肯定会超时的。

不可能优化骑士的数量。但是 $z$ 的数量却可以限制成一个常数。可以证明， 国王只有在八个方向（上下左右、左上左下右上右下），并且步长不超过2（包括斜线步长）的附近的点上，被骑士捎上，才有可能节省步数。

在其他任意 $zz$ 点接国王，比 骑士从 $zz$ 点跳进这个范围接了国王，然后返回 $zz$ 点， 不会节省步数。另外有个特例，如果国王一直按斜线走，让骑士接还不如不接。。。。所以就不考虑了。。

这样 $Z$ 的数量减少到 17 个。 只需要检查17个点能否节省步数就可以了。

每个集结点模拟的时间复杂度可以控制在 $O(V)$ 以内， 因此总的时间复杂度可以控制在 $O(V^2)$。



#### [Code](../../cpp/19/p1930.cpp)


