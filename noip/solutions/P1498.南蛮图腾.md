### P1498 南蛮图腾

算法标签: **分治**, **字符串**, **深度优先搜索,DFS**, **递归**
其他标签: **湖南**


#### Description

#### Analysis

很有意思的一道题目。 当然用递归方法可以求解。 没有考虑这个方法。

有一种更方便的解法： 根据杨辉三角形的规律：

```
       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\
```

```
        1                    
       1 1 
      1 0 1 
     1 1 1 1 
    1 0 0 0 1 
   1 1 0 0 1 1 
  1 0 1 0 1 0 1 
 1 1 1 1 1 1 1 1 
```

是不是很像， 其中奇数行的 1 ，表示 `/\`， 偶数行的两个 1 表示 `/__\`。 无论奇偶， 0 都表示两个空格。

数字的那个可以用这样看：
```
1                    
1 1 
1 0 1 
1 1 1 1 
1 0 0 0 1 
1 1 0 0 1 1 
1 0 1 0 1 0 1 
1 1 1 1 1 1 1 1 
```

对于第 `i` 行， `a[0] = a[i] = 1` 固定，  `a[j] = a[j] ^ a[j - 1]`， 这样从后向前可以计算出新的一行的 `a[j]` 值。

然后输出，根据奇偶行，以及 `a[j]` 的值判定输出就可以了。

```cpp
int main()
{
    int n, i, j;
    int a[1030] = {1};

    scanf("%d", &n);

    n = (1 << n);

    for (j = 0; j <= n; ++j)
        a[j] = 1;

    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < n - i - 1; ++j)
            putchar(' ');
        for (j = i - 1; j > 0; --j)
            a[j] ^= a[j - 1];
        if (i % 2 == 0)
            for (j = 0; j <= i; ++j)
                printf(a[j] ? "/\\" : "  "); //奇数行
        else
            for (j = 0; j <= i; j += 2)
                printf(a[j] ? "/__\\" : "    "); //偶数行
        printf("\n");
    }
    return 0;
}
```

#### [Code](../cpp/p1498.cpp) 

