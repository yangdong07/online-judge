### P1515 旅行

算法标签: **动态规划**


#### Description

你要进行一个行程为7000KM的旅行，现在沿途有些汽车旅馆，为了安全起见，每天晚上都不开车，住在汽车旅馆，你手里现在已经有一个旅馆列表，用离起点的距离来标识，如下：

0， 990， 1010， 1970， 2030， 2940， 3060， 3930， 4060， 4970， 5030， 5990， 6010， 7000

但在出发之前可能还要增加一些旅馆。

现在旅行社为了节约成本，要求每天至少行驶A公里，国家旅行社为了安全起见，要求每天最多只能行驶B公里。

你想知道一共有多少种旅行方案。

#### Analysis

此题是动态规划题。不过需要一点分析才能看出来。

一般求什么方案数的基本脱离不了动态规划。

动态规划问题的基本思路： 1. Backtracking（自上而下，遍历所有方案）；2. 状态制表，避免重复； 3. 迭代状态（自下而上），子问题构造全局问题。

1. Backtracking： 如果遍历所有方案： 可以发现一个树结构：

每个结点是一个旅馆： 两个分支表示 住 或者不住。 第 i 层就是 第 i 个旅馆。

如果住： 那么从这里作为新的起点， 开始新的旅程。。
如果不住： 那么这里只是旅途中的一个风景。。。保留上一个的“起点” 信息。

当然有的节点是不允许的：比如如果从上一个起点的旅程 大于 B 都是不允许的。这里可以剪枝回溯。

有的节点只有一个分支：例如旅程小于 A，则不可停留。

所有能访问到的叶子结点就是一个合理方案。

2. 动态规划： 可以发现，可以保存每个旅馆的状态： 以这个旅馆为起点的旅行方案数。

从后向前，更新每个旅馆的状态：每以一个旅馆为起点，它的所有方案包括： 访问 +1 旅馆； 访问 +2 旅馆； 访问 +3旅馆； 直到超出旅程。 此旅馆为起点的方案数，等于之后可一次旅程访问到的旅馆的方案数的总和。

非常棒的题目。

```cpp
int main()
{
    int hotels[MAX_N] = { 0, 990, 1010, 1970, 2030, 2940, 3060, 3930, 4060, 4970, 5030, 5990, 6010, 7000 };
    int nHotel = 14;
    int minTrip, maxTrip;
    int n, i, j;
    scanf("%d %d %d", &minTrip, &maxTrip, &n);
    for (i = 0; i < n; ++i)
        scanf("%d", &hotels[nHotel + i]);
    nHotel += i;
    sort(hotels, hotels + nHotel);

    int dp[MAX_N], distance;
    dp[nHotel - 1] = 1;
    for (i = nHotel - 2; i >= 0; --i)
    {
        dp[i] = 0;
        for (j = i + 1; j < nHotel; ++j) {
            distance = hotels[j] - hotels[i];
            if (distance > maxTrip) break;
            else if (distance >= minTrip) dp[i] += dp[j];
        }
    }
    printf("%d", dp[0]);

}
```

#### [Code](../cpp/p1515.cpp)
