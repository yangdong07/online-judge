### P1006 传纸条

算法标签: **动态规划,动规,dp**, **费用流**
其他标签: **NOIp提高组**, **2008**, **高性能**


#### Description

#### Analysis

非常有意思的一道题目。

刚开始都不会做。。看了题解才有思路。

这个问题的子结构隐藏的比较深。。一般还真想不出来。

1. 来回传两张纸条，路径不相交，等价于同时从 $(1, 1)$ 传到 $(m, n)$ 两张纸条，并且传递过程中，路径不相交。
2. 同时传递两张纸条，在第 $z$ 步，两张纸条的坐标必须满足 $x_1 + y_1 = x_2 + y_2 = z$， 实际上是落在对角线的两个点上。

有了第 $z$ 步的 两个点，就比较容易看出来问题解的子结构了。

为了达到这两个点：

- 从左边两个点，均平移；
- 从上方两个点，均下移；
- $(x_1, y_1 - 1)$ 点右移， $(x_2 - 1, y_2)$ 点下移
- $(x_1 - 1, y_1)$ 点下移， $(x_2, y_2 - 1)$ 点右移

这就得到了一个递归解。问题基本解决了 90%。

关于递归解的数组，需要三个维度：

1. 第 $z$ 步
2. 从 $z$ 步对应的对角线，选择两个点，这需要至少两个维度表示（比如两个点的纵坐标 $y_1$， $y_2$， 可以确定另外两个坐标 $x_1 = z - y_1$， $x_2 = z - y_2$。

这样DP就可以循环计算：

1. `z ~ [1, m + n - 1]`
2. `y1 ~ [1, n - 1]`， `x1 ~ [z - y1, m]`
3. `y2 ~ [y1 + 1, n - 1]`， `x2 ~ [z - y2, m]`

但是确实有点坑，RE了好几个点，因为在计算 `x1` `x2` 的时候，不小心就越界了。

换一个角度考虑动态规划的状态。

1. 考虑每两个点： 他们的距离（水平距离和垂直距离），定义为 `d`，一般两个点都是一个左下，一个右上，在一条对角线上。 水平距离和垂直距离是相等的。 
2. 确定第一个点 `(r, c)`， 以及 `d` 就能得到两个点。

所以用 `r, c, d` 三个值表示递归解的状态，并且范围都是正数，边界也很好确定。但是也有一些坑。注意一下就可以了。

因为每 2个点的解，依赖其左上方的 **某些** 组合的点的解，所以循环求解的顺序是：

1. `r : 2 ~ m`
2. `d : m - r ~ 1`
3. `c : 1 ~ n - d`

```cpp
int max(int a, int b) { return a > b ? a : b; }

int main()
{
    const int MAX_N = 51;
    int m, n, i, j;
    int a[MAX_N][MAX_N];
    int dp[MAX_N][MAX_N][MAX_N] = {0};

    scanf("%d %d", &m, &n);

    for (i = 1; i <= m; ++i)
        for (j = 1; j <= n; ++j)
            scanf("%d", &a[i][j]);

    int r, c, d;
    int max_s;
    for (r = 2; r <= m; ++r)
    {
        for (d = r - 1; d > 0; --d)
            for (c = 1; c <= n - d; ++c)
            {
                max_s = dp[r][c - 1][d];                 // left, d
                max_s = max(max_s, dp[r][c - 1][d + 1]); // left, d + 1
                max_s = max(max_s, dp[r - 1][c][d]);     // up, d
                max_s = max(max_s, dp[r - 1][c][d - 1]); // up, d + 1
                dp[r][c][d] = max_s + a[r][c] + a[r - d][c + d];
            }
    }
    printf("%d", dp[m][n - 1][1]);

    return 0;
}
```



#### [Code](../cpp/p1006.cpp) 

