### P1005 矩阵取数游戏

算法标签: **动态规划,动规,dp**, **进制**, **高精**
其他标签: **NOIp提高组**, **2007**


#### Description

#### Analysis

这题如果做过 [P2858 奶牛零食] 就会发现都差不多。 不过是多了一个维度求和而已。 动规部分就懒得说了。参考 P2858 题解。

主要的问题是：高精度。

高精度知识还是比较欠缺，尤其涉及到进制转换。

1. 二进制和十进制之间是如何相互转换的？ 高精写法？
2. 二进制如何转换成其他任意进制？ 高精写法？
3. 如果不要求通用写法， 只写一个 `uint128_t` 该如何实现？

这一道题其实 用 `uint128_t` 就够了。注意 `uint128_t` 的是通过2个 `uint64_t` 即 `unsigned long long` 型实现。

这道题主要涉及的高精度运算有：

1. 加法。
2. 乘 幂2 操作：如果用二进制高精，或者 `uint128_t` ，使用普通的移位操作就可以了。 如果用十进制高精，会麻烦一些。
3. 比较操作：取最大值。
4. 10进制打印输出。这里如果用十进制高精就很简单； 但是用二进制高精或者`uint128_t` 就比较麻烦，我在这里卡了一天时间。主要涉及进制间转换问题。

进制间转换最关键的一步其实是实现 `divmod` 方法： 即除法和求余。我在这个地方也卡了很久，一直没找到一种合适的方法。

有的方法太通用，写起来太麻烦； 我又不愿意写太硬的代码（比如直接除10），最后终于找到一个折中的方法：

```cpp
    pair<uint128_t, uint32_t> divmod(const uint32_t &divisor) const
    {
        if (divisor == 0)
            throw domain_error("Error: division or modulus by 0");
        else if (divisor == 1)
            return pair<uint128_t, uint32_t>(*this, 0);
        
        uint64_t parts[4] = {UPPER >> 32, UPPER & 0xffffffff, LOWER >> 32, LOWER & 0xffffffff};
        uint64_t d, r = 0, q[4];
        for (int i = 0; i < 4; ++i)
        {
            d = (r << 32) + parts[i];
            q[i] = d / divisor;
            r = d % divisor;
        }
        return pair<uint128_t, uint32_t>(uint128_t((q[0] << 32) | q[1], (q[2] << 32) | q[3]), (uint32_t)r);
    }
```
就是除数是一个 `uint32_t` 整型， 那么把 `uint128_t` 分成 4段 `uint64_t`， 每段先除 `base` ，余数左移 32位后和下一个段相加，再 `divmod(base)`。 最后将商拼起来。

这里需要一个证明就是如果第一段的 $a_1 = q_1B + r_1$，那么下一段 $r_1 *2^{32} *B + a_2$ 不会超过 $B * 2^{32}$ （即表示商不会超过 $2^{32}$ 不会影响前一段）

这其实比较容易看出来： $r_1 \leq B - 1$，$a_2 < 2^{32}$。

有了 `divmod` 之后，就可以做任意的进制转换了。除除除，余数变字符，白毛浮绿水，红掌拨清波。


#### [Code](../cpp/p1005.cpp) 

