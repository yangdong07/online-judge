### P1280 尼克的任务

算法标签: **动态规划,动规,dp**, **排序**, **枚举,暴力**


#### Description

#### Analysis

动态规划找到递归方程基本上就解决了一大半问题。

这个与活动选择问题有一些不一样的地方，它不能用贪心算法找到最优解，因为贪心选择并没有对应的最优子结构。

正向递归过程很简单， 令 `dp[i]` 为在时间点 `i` 的最优解（最多闲暇时间）。

1. 如果在当前时间点没有任务， `dp[i] = dp[i + 1] + 1`， 最多闲暇时间为下一个时间点的最优解 + 1
2. 如果在当前时间点有若干任务， `dp[i] = max(dp[i], dp[i + t])`， `t` 为每个当前时间点的任务的持续时间。`dp[i]` 初始为 0。

因为前面的值依赖后面的值，所以一种方法是用递归求解；另一种方法是从后向前填dp表。

仍然有两个数据结构上的小问题：如何判断当前时间点有没有任务？ 如果有，是哪几个任务？

判断当前时间点有没有任务很简单， 用一个计数数组就可以了。但是每个时间点有哪些任务可以选择呢？

最朴素的想法就是用 `vector` 在每个时间点上保存一个任务序列。 这种很方便。 并且时间复杂度可以证明为 $O(N + M)$ ，$N$ 为总时间； $M$ 为任务数量。

还有一种精巧的思路是，先对每个任务按照开始时间排序， 从后向前填表的时候，在每个时间点上“用”掉相应数量的任务， 然后任务的索引递减就行了。

这种算法时间复杂度为 $O(N + M\log M)$， 写起来较容易出错。

#### [Code](../cpp/p1280.cpp) 

