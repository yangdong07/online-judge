### P1832 A+B Problem（再升级）

算法标签: **动态规划,动规,dp**, **数论,数学**, **素数判断,质数,筛法**, **背包**, **递推**
其他标签: **洛谷原创**

#### Description

哥德巴赫猜想：任一大于2的偶数都可写成两个质数之和。

任意一个数都可以分解成若干素数之和， 现在的问题是：给定一个数，问有多少种分解方法？

比如： 7 = 2 + 2 + 3 = 2 + 5 = 7， 是 3 种方法。

#### Analysis

这是一道数学题。但是可以通过动规来解决。

考虑若干素数，问题可以变成： 用若干素数组成一个数，有多少种组合方式？

令 $dp(p_n, m)$ 表示用前 $n$ 的素数组成 $m$ 有多少种方法。包括两种情况：

- 不使用素数 $p_n$： $dp(p_{n-1}, m)$
- 在 $m$ 中加入一个素数 $p_n$： $dp(p_n, m - p_n)$

注意这里 $m - p_n$ 也有可能继续使用 $p_n$ 的情况。所以是在同一层。 这一点很难直观感觉到，但实际上可以将所有分支画出来，可以发现考虑了所有 $p_n$ 的情况： 没有 $p_n$， 有 1个 $p_n$， 有 2个 $p_n$， 有多个 $p_n$，并且每种情况都只考虑了一次。

$dp(p_n, m) = dp(p_{n-1}, m) + dp(p_n, m - p_n)$

这个动规方程很像 完全背包问题的动规方程。 当前的状态依赖上一层的状态和同层前面的状态，所以可以从前向后计算。

```cpp
bool is_prime(int n)
{
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) return false;
    return true;
}

int main()
{
    int n, i, j;
    long long dp[MAX_N] = {0};

    scanf("%d", &n);

    dp[0] = 1;
    for (i = 2; i <= n; ++i)
        if (is_prime(i))
            for (j = i; j <= n; ++j)
                dp[j] += dp[j - i];
    printf("%lld", dp[n]);

    return 0;
}
```


#### [Code](../cpp/p1832.cpp) 

