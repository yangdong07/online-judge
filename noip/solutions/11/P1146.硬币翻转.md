### P1146 硬币翻转

算法标签: **搜索**, **数论,数学**, **模拟**


#### Description

有 $N$ 个硬币，全部正面朝上（0）； 每次翻转 $N-1$ 个硬币，视为一次操作。 求一个最短的操作序列 将所有硬币全部反面朝上（1）。


#### Analysis

初看这题似乎很难下手。 但是观察一个样本就可以帮助找到一些规律。 比如 6枚硬币：

```
0: 000000 -> 111111
1: 011111 -> 100000
2: 110000 -> 001111
3: 000111 -> 111000
4: 111100 -> 000011
5: 000001 -> 111110
6: 111111
```

翻 $N - 1$ 个硬币，等价于翻 $N$ 个硬币，然后再翻回 $1$ 个硬币。

因此，想要把所有硬币都翻过来，至少需要 $N$ 次操作。

另外观察一下其操作步骤： 发现每两次操作，其实只改变了两位。 可以证明： 每次翻转 $N-1$ 个硬币，$N$ 必须是偶数， 才能将所有硬币全部翻转。

证明如下：

每个硬币想要翻面必须经过奇数次操作。如果硬币个数是奇数个， 那么总的操作次数（所有硬币）为奇数。 但是每次批量翻转 $N-1$ 个硬币，无论操作多少次，总操作次数都是偶数， 所以永远不可能将硬币全部同时翻面。

观察操作步骤，稍微想一下，就可以发现其实就相当于每次只翻一个硬币：在第奇数步 输出的 0/1 翻转就可以了。

```cpp
int main()
{
    int n, i;
    char s0[MAX_N], s1[MAX_N];
    scanf("%d", &n);
    for (i = 0; i < n; ++i)
    {
        s0[i] = '0';
        s1[i] = '1';
    }
    s0[n] = s1[n] = '\0';

    printf("%d", n);
    for (i = 0; i < n; ++i)
    {
        s0[i] = '1';
        s1[i] = '0';
        if (i & 1) printf("\n%s", s0);
        else printf("\n%s", s1);
    }
}
```

上面是一个省事的写法： 准备两个字符串，交替输出就可以了。



#### [Code](../cpp/p1146.cpp)
