
### P1194 买礼物

算法标签: **图论**, **生成树**

#### Description


#### Analysis

这道题有点不那么直观，也不是很严谨。

题目要求：连续访问若干个点（购买礼物），使得总的钱数最少（访问代价）最小，因此这是个最短路问题。

如果矩阵中 `price[i][j] == 0` ，则说明没有优惠。 但是注意，没有优惠并不代表不能购买，只是得按原价购买罢了。所以还是连通的。

一开始我以为需要求若干次生成树。后来发现只需要把 `price[i][j] == 0` 的点变成 cost 就行了。

WA 了一次，是因为还要考虑 `price[i][j] > cost` 的情况，这种还不如单独购买， 所以将 `price[i][j] > cost` 的边也改成 cost 就行了。

#### [Code](../../cpp/11/p1194.cpp)


