
### P1119 灾后重建

算法标签: **图论**, **最短路**, **Floyd**
其他标签: **高性能**

#### Description


#### Analysis

这题居然挂个标签“生成树” 真是误导。

真如某篇题解所说，这篇加深了我对 Floyd-Warshall 算法的理解。

题目给的数据比较方便，已经假设了编号为 0，1，... N - 1 的点，可用时间是严格升序的。

并且每次查询的时间也是升序的。

这道题的一般思路是：根据查询时间判断有多少点可用。当只有前 $n_k$ 个点可用的时候，只用这 $n_k$ 个点做 Floyd-Warshall 算法。

总的时间复杂度是： $1^3 + 2^3 + \cdots + n^3 = O(n^4)$， 这显然是不理想的。

这时候就需要深刻的理解 Floyd-Warshall算法了。

Floyd-Warshall 算法是这个样子：

```cpp
for (k = 0; k < n; k++)
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            if (dist[i][k] + dist[k][j] < dist[i][j])
                dist[i][j] = dist[i][k] + dist[k][j];
```

`dist[i][j]` 的初值是 $i$ 到 $j$ 的直接距离： 中间不经过任何点。

在循环到 $k$ 的时候，对每个点对 $(i,j)$ 找的是经过且只经过 $\{0, 1, \cdots, k\}$ 的最短路。

根据动态规划，这个最短路实际上是 经过 $\{0, 1, \cdots, k - 1\}$ 的最短路，以及经过 $k$ 的最短路， 两个值的最小值。

当只有 $n_k$ 个点可用的时候，可以按照动态规划更新最短路信息： 对所有点对的最短路 只需要计算一次经过第 $n_k$ 个点的最短路，然后与之前的值比较，取个最小值就行了。

在这道题中：

1. 因为其他点还不可用，所以任意点对 $(i, j)$ 之间的最短路就是只经过可用点的最短路或者直接通路。
2. 如果 $i$ 点 或 $j$ 点不可用，那么 $(i, j)$ 之间的直接通路是无效的，可以计算，但暂时不用考虑。

所以每次有一个点可用的时候，计算一次内部循环就可以了。 总的时间复杂度就是  Floyd-Warshall 算法的复杂度 $O(n^3)$。






#### [Code](../../cpp/11/p1119.cpp)


