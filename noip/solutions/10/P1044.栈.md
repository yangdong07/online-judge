### P1044 栈

算法标签: **动态规划,动规,dp**, **卡特兰,Catalan**, **数论,数学**, **栈**, **递推**
其他标签: **NOIp普及组**, **2003**


#### Description

题目大意： 问一个序列  $1, 2, 3...n$， 在经过入栈出栈的随机操作后，最后全部出栈，可以转变的序列的个数。

#### Analysis

每个自己做出来的动规题都是非常有趣的，哈哈哈

这题给了图，就很好观察。 一开始我就试图找一个递归结构， 但是总不是特别满意。

找了会儿，发现可以用 $dp(i, j)$ 表示 $i$ 个未入栈， $j$个已在栈中，可以形成的序列的个数。

那么问题的最后答案就是 $dp(n, 0)$

在每个状态有两种选择， 出栈一个或者入栈一个，因此递归方程可以写成：

$dp(i, j) = dp(i, j - 1) + dp(i - 1, j + 1)$

注意一些边界解：

- $dp(0, j) = 1$， 相当于栈包括了所有数，全部出栈就行了， 就1种排列。
- $dp(i, 0) = dp(i - 1, 1)$， 相当于栈是空的。放进去一个。

```cpp
#include <cstdio>

#define MAX_N 20

int main()
{
    int n, i, j;
    scanf("%d", &n);

    long long dp[MAX_N] = {0};

    // i = 0;
    for (j = 1; j <= n; ++j)
        dp[j] = 1;

    for (i = 1; i < n; ++i)
    {
        dp[0] = dp[1];
        for (j = 1; j <= n - i; ++j)
            dp[j] = dp[j - 1] + dp[j + 1];
    }
    printf("%lld", dp[1]);
    return 0;
}
```

注意以上代码的三个细节：

- 由于 $dp(i, j)$ 依赖上层的后一个值，和当前层的前一个值（按照 $i$ 分层）， 可以从两维压缩成一维。
- `dp[0] = dp[1]` 对应边界解
- 最后一层不用全部求解，直接返回倒数第二层的 `dp[1]`。


最后的数可能很大，因为感觉上类似斐波那契数，是指数级的，所以开个 `long long`。 题解中说是 卡特兰数。 以后再研究。


#### [Code](../cpp/p1044.cpp) 

