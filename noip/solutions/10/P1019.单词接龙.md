### P1019 单词接龙

算法标签: **字符串**, **搜索**
其他标签: **NOIp提高组**, **2000**


#### Description

#### Analysis

也是一个很棒的 回溯题。

单词接龙游戏。

这个问题很容易想到用深度搜索，回溯剪枝。 每次找一个可以接的单词，拼接后继续搜索，直到找不到为止。

其难点主要是在判断两个单词是否可以拼接上面。 消耗了我一亿脑细胞。

其实可以先做一个表，来表示两个单词重叠的长度。

具体两个单词重叠可以这么计算：（题目有个要求，单词是重叠，但不是包含关系）

```
s1: 0 1 2 ... i ... l1-1
s2:           0 ... l2-2 l2-1
```

观察 `i` 可以从哪里开始？

- 如果 `l1 <= l2`，那么 `i` 可以从0开始，但是为了避免包含关系， `i > 0`
- 如果 `l1 > l2`，那么 `i` 可以从 `l2 - l1` 开始，为避免包含关系， `i > l2 - l1`

所以用 `i0 = l1 < l2 ? 0 : l1 - l2;` 表示开始位置。

在 `j = 0; j < l1 - i` 范围内， `0 <= j < l1 - i < l1 - l2 + l1 = l2` 是安全的。


```cpp
int concate(const string &s1, const string &s2)
{
    int l1 = s1.size();
    int l2 = s2.size();

    int i0 = l1 < l2 ? 0 : l1 - l2;  // i 的起点位置
    int j;

    // 反序以保证最小重叠部分
    for (int i = l1 - 1; i > i0; --i)
    {
        for (j = 0; j < l1 - i; ++j)
            if (s1[i + j] != s2[j])
                break;
        if (j == l1 - i)
            return j;
    }
    return 0;
}
```


#### [Code](../../cpp/10/p1019.cpp)
