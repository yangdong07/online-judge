### P1031 均分纸牌

算法标签: **概率论,统计**, **模拟**, **贪心**
其他标签: **NOIp提高组**, **2002**


#### Description

有 N 堆纸牌，编号分别为 1,2,...,N 。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

#### Analysis

不要被题目吓着了，其实想一想很简单。

规则可以简化成： 只允许在相邻牌堆移动纸牌。

我有一个猜想。。不过 markdown 太小，就不写证明了： 最多的移动次数也就是 $N- 1$。

现在问最少的移动次数。

考虑这样一种情况： 所有牌堆按牌多牌少的顺序有序排列，那么可见只需要 $N-1$ 次移动，逐渐从高的地方往低的地方移动就行。

实际情况比较复杂： 从高的地方往低的地方移动一次，之前的那堆就不用再考虑了，计数 + 1。 从新的地方开始。

如果这个地方的牌数（从左边移过来的加上原来就有的）比平均值少，怎么办？ 没关系，先欠着，将来总会从右边移过来的。 计数 + 1。 当然欠多少要记着。

这个欠多少，和从左边移过来多少，其实用一个值表示就可以了。 正数表示移过来， 负数表示欠多少，也就是将来要移过去多少。

如果这个值（左边给的或者欠左边的） + 本地值 == 平均数， 那么就不用计数了。 左边给多少的移动，左边已经记过了； 左边欠多少的移动，左边也记过了。 所以到这里如果不欠不借，不需要移动。


一个循环遍历就能解决问题。

#### [Code](../cpp/p1031.cpp)
