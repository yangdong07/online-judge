
### P1203 [USACO1.1]坏掉的项链Broken Necklace

算法标签: **动态规划,动规,dp**, **字符串**, **搜索**
其他标签: **USACO**

#### Description

一个项链 有 $n$ 个珠子， 颜色分别是 `b` 表示蓝色 `r` 表示红色， `w` 白色。

从某一点断开，从断点两端开始取珠子，最多能取到多少同色的珠子？ （白色可以视为 蓝色，也可以视为红色）。

原题链接： http://train.usaco.org/usacoprob2?a=f08aR1BpCL9&S=beads

#### Analysis

因为 $n$ 很小，单纯的通过模拟 $O(n^2)$ 就可以解决问题。

这里用 动规的方法解决，感觉更优雅一些。

观察项链就会发现，从某一个珠子向左看过去（包括这个珠子），有多少同色的珠子，其实只依赖于 1. 前一个珠子什么颜色；2. 如果同色，前一个珠子的前面有多少同色的珠子。

向右看同理。 一开始我尝试只用两个数组，分别表示向左看，向右看的同色珠子数。后来发现写起来有点费劲。 其实完全可以多加一组状态： 向左看的红色珠子有多少； 向左看的蓝色珠子有多少； 向右看的红色珠子有多少； 向右看的蓝色珠子有多少。

**一个环形数组可以用两个数组拼接表示。**

最后答案也很简单： 在每个点 $i$ 和 $i+1$ 上分别向左看和向右看，取同色最多的数量相加。 所有方案取最大值。 并且最后这个最大值不会超过项链总长。

#### [Code](../../cpp/12/p1203.cpp)


