
### P3366 【模板】最小生成树

算法标签: **生成树**
其他标签: **高性能**

#### Description


#### Analysis

生成树模板题，主要用了两种算法： Prim 和 Kruskal，各做了一遍。

感觉 Prim 算法可以和 Dijkstra 算法写成一种模式。。。都是优先级队列

Prim 存的是 (邻接点 和 边权)。 Dijkstra 存的是 (邻接点 和 最短路估计)。

Prim 需要明确的访问标记，用来判断访问的点是否在 $S = V_A$ 中；Dijkstra 需要一个最短路数组（也当访问标记用）。

Prim 也可以用所谓的 **堆优化** 的方式来提高效率。

普通的 Prim 仅使用标记访问数组，在取出的时候标记为已访问（参考 https://www.hackerearth.com/zh/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ ）。 这样做有一个问题是，有些未访问的点可能被重复放进队列。这样是非常浪费的：凭空增加了队列的长度以及一些无用的操作。

一种策略类似于 Dijkstra 定义一个 **最短边数组**，初始化为 `INF`。 这个数组保存以每个顶点为终点的边的最小边权。 只有当发现一条边，并且边的终点没有被访问（意味着这条边通过割），并且边权比已知的边权小（最短边数组）的时候，才更新一下最短边数组，然后加入到优先级队列。 这样可以减少对一些大边的重复比较和计算，可以得到比较好的优化。

但是Prim 算法不可以像 Dijkstra 那样把标记访问数组给省略掉。 因为这个标记访问数组有一个非常重要的作用是定义割  $(V_A, V - V_A)$。 单纯用 **最短边数组** 是否达到最小来判定是否访问过是错误的。比如某一个点 b 连接三条边，边权分别为 $w(a1, b) = 1$，$w(a2, b) = 2$，$w(a3, b) = 3$。 如果从 $a3$ 出发的生成树，并且其他所有边权都大于 3， 会选择 $(a3, b)$ 加入 $A$，将 $b$ 加入 $S$，如果不做访问标记而是通过最短边比较，在未来某个时刻，会将 $(a1, b)$ 或者 $(a2, b)$ 加回到队列。这就构成了回路，这是错误的。

在 Dijkstra 算法中可以将标记访问数组省掉是因为，它是从某一点出发，对每个点的最短路估计进行松弛操作。它并不关心是否环回访问了某个点： 因为非负权路环回去也不可能比这个点的最短路更小，即使相等，这个点也只可能被松弛到最小一次，加入队列一次。这样就阻断了环路访问，就可以安全的省略掉访问标记数组。



经过优化后，Kruskal 和 Prim 算法都不用太考虑重边的情况。除非特殊情况必须要节省空间。 否则完全可以把所有边都加进去。


#### [Code](../../cpp/33/p3366.cpp)


