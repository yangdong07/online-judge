

参考 《算法导论》 图的基本算法一章


## 图的表示

要表示一个图 $G = (V, E)$，有两种标准的方法：
- 邻接表
- 邻接矩阵

### 邻接表

每个点一个 `list` ，用来保存与之相连接的点，表示一条边。

- 由一个包含 $|V|$ 个 list 的数组 $Adj$ 表示，每个list 对应于 $V$ 中的一个顶点。
- $Adj[u]$ 包含所有满足条件 $(u,v) \in E$ 的顶点。

邻接表的储存空间为 $\Theta(V + E)$

如果不好理解，考虑 **树也是图的一种**。树中每个结点有若干子节点，这就是邻接关系。


### 邻接矩阵
设顶点按任意方式编号为 $1, 2, \cdots, |V|$，那么 $G$ 的邻接矩阵为一个 $|V| \times |V|$ 的矩阵  $A=(a_{ij})$，满足：

$$a_{ij} = \left\{ \begin{array}{l} 
1 \quad &if \ (i, j) \in E \\
 0 \quad &else \\ \end{array} \right. $$

邻接矩阵的储存空间为 $\Theta(V^2)$
如果仅用1、0，可以只用一个二进位表示一条边。

### 地图

还有一些非标准化的方式。比如地图，每个点只能访问上下左右四个点（邻接关系），如果有障碍物还不能够访问。



### 权值
如果对边，有加权函数 $w: E \to R$，也可以存储在邻接表或邻接矩阵中。


## 图的遍历

DFS 和 BFS 在树结构中用的比较多，但实际上它也是图的基本算法。

### BFS

主要思想：从起点 $s$ 开始，遍历从 $s$ 可以达到的所有顶点（广度遍历）。然后对这些顶点重复 $s$ 的动作。

BFS 可以在图中找到最短路径（无权），即从点 $u$ 到 点 $v$ 的最少边数。

BFS 可以得到一个树结构： 包括从点 $s$ 出发能够访问到的所有点。每个点 $v$ 所在深度为 从 $s$ 点到 $v$ 的最短距离。 这个树叫做广度优先树。

根据算法，每个点至多被访问到一次，入队和出队时间为 $O(1)$，则队列操作全部时间为 $O(V)$。每个顶点出队时，才扫描邻接表，总的操作时间有 $O(E)$；初始化开销 $O(V)$，所以BFS的总运行时间为 $O(V + E)$


题目：

- P1126，机器人搬重物


### DFS

主要思想： 从起点 $s$ 开始，尽可能深的搜索一个图。

对于最新发现的顶点，如果还有以此为起点而未探测到的边，就沿此边继续探测下去。当顶点 $v$ 的所有边都已被探寻过后，搜索开始回溯发现$v$ 的点 $u$ 的其他未探寻的边。

想象一个走迷宫过程，每个岔路口可以视为一个点。一个常见的策略就是 DFS 搜索： 每次遇到分岔路口，选择一个方向继续走，直到走不通，或者相邻点都被访问过。回退到上一个路口选择其他路开始搜索。

