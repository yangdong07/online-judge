

## 最短路问题

参考 https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#shortestPath



一个简单的说法就是在带权图中，找到一条起点到目标点的路径，路径权和最小。

下面是具体定义。

已知一个带权有向图 $G=(V, E)$，和加权函数 $w: E \to \boldsymbol{R}$ 为从边到实数权值的映射。路径 $p = \langle v_0, v_1, \cdots, v_k \rangle$ 的权是指其组成边的的所有权值之和：

$$w(p) = \sum_{i=1}^k{w(v_{i-1}, v_i)}$$

定义从 $u$ 到 $v$ 间的**最短路径的权**为：
$$ \delta(u, v) = \left\{ \begin{array} {l}
\min{\{w(p): u \leadsto v \}}  \quad &if \ p\ exist \\ 
\infty \quad &else \\
\end{array} \right. $$
从顶点$u$ 到顶点 $v$ 的**最短路径**定义为权 $w(p)=\delta(u, v)$的任何路径。

广度优先搜索算法（BFS）实际上是无权图的最短路径算法


## Bellman-Ford 算法

主要思想：**从源点$s$ 开始，对每条边进行一次 松弛（RELAX）操作；重复 $|V|-1$ 次。**

松弛操作：对每个点设置一个值 $d[v]$， 表示为 从 $s$点 到 $v$ 点的 **最短路径估计**， 对每条边 $(u, v)$ 进行一次 **松弛操作**，表示 如果 $d[u] + w(u, v) < d[v]$ ，则更新 $d[v] = d[u] + w(u, v)$

时间复杂度为 $O(VE)$

可以感觉，也可以证明，经过 $|V|-1$次 对所有边的松弛操作之后，所有的 **最短路径估计** 都已经到了最小值。

Bellman-Ford 算法还可以检查是否有负权回路存在。 

所谓负权回路是指如果路径上存在一个回路权和为负值，则沿着这个回路循环几次都能使得路径总权和不断减小，也就不存在实际意义上的最短路径。

对每条边检查 $d[u]$ 和 $d[v]$ 是否满足三角不等式
$$d[v] \le d[u] + w(u, v)$$
如果不满足，说明有负权回路存在。


## Dijkstra 算法

Dijkstra算法主要思想： **每次选择 $d[v]$ 最小的点的相邻边进行松弛操作。**

Dijkstra算法是贪心算法，使用时还需要一个条件：假设路径中所有边的权重都是非负的，也就说不存在负权回路。

Dijkstra算法使用了最小优先级队列的三个操作：

- INSERT （初始化）， 共$|V|$次操作
- EXTRACT-MIN，   共 $|V|$ 次操作
- DECREASE-KEY （在松弛步骤中更新 $d[v]$值），共 $|E|$ 次操作

所以 Dijkstra 算法的时间复杂度依赖最小优先级队列的实现方式：

||数组实现|二叉堆|
|--|--|--|
|INSERT（初始化）|$O(1)$ |$O(1)$ 由于初值的特殊性|
|EXTRACT-MIN   |$O(V)$  |$O(\log V)$|
|DECREASE-KEY  |$O(1)$  |$O(\log V)$|
| 算法复杂度 | $O(V^2 + E)$ | $O(V\log V + E\log V)$|

一种稀疏图的界定： $E = O(V)$， 即每个顶点只有常数条边（比如地图中每个点只能访问相邻的四个点，四条边）。




## 
