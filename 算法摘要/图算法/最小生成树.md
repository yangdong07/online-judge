
## 最小生成树

新发现了个网站，介绍算法，并且有非常好的代码模板。但是算法原理没怎么提。
https://www.hackerearth.com/zh/practice/algorithms/graphs/minimum-spanning-tree/tutorial/

### What is a Spanning Tree?

Given an undirected and connected graph $G = (V, E)$, a spanning tree of the graph $G$ is a tree that spans $G$  (that is, it includes every vertex of $G$) and is a subgraph of $G$(every edge in the tree belongs to $G$)

注意三个方面：

1. 连通无向图 $G=(V, E)$ 的生成树
2. 有 $|V|$ 个点，即 $G$ 的所有点
3. 有 $|V - 1|$ 条边， 是 $G$ 的一个子图。


### What is a Minimum Spanning Tree? （MST）

The cost of the spanning tree is the sum of the weights of all the edges in the tree. There can be many spanning trees. Minimum spanning tree is the spanning tree where the cost is minimum among all the spanning trees. 

对于一个权图， 定义生成树的 cost 是树中所有边权之和。 可能有多个生成树。具有最小 cost 的生成树为最小生成树。 如果边权不唯一，则最小生成树也有可能有多个。

《算法导论》

给定一个 **加权无向连通图** $G=(V, E)$，对图中每条边 $(u, v) \in E$，有一个权值 $w(u, v)$。
希望找出一个无回路的子集 $T \subseteq E$，连接了所有的顶点，并且权值之和 

$$w(T) = \sum_{(u,v) \in T}{w(u, v)}$$

最小。因为 $T$ 无回路且连接所有顶点，则它必然是一棵树，称为生成树（spanning tree）。把确定树$T$ 的问题称为最小生成树问题。


### 给定一个加权无向连通图，如何找到最小生成树？

从一个空图开始，每次选择一条边加入，如果能够保证：

1. 不会构成回路，即正在构建一颗成长的树。
2. 加入这条边之后，这个正在成长的树仍然是某个最小生成树的一部分（子图）。

那么最终会得到一颗最小生成树。如果最小生成树具有最优子结构，那么这种策略是可行的。

满足上面两个条件的边有个学名叫做 **安全边（safe edge）**， 如果 $A \subseteq T$ ，$T$ 是一个最小生成树（MST）。对于一条边 $(u, v)$， 如果 $A \cup \{(u, v)\} \subseteq T$， 则称 $(u, v)$ 是一条 **安全边**， 或者说对于 $A$来说是 **安全的**。


定义几个概念， 对于无向图 $G = (V, E)$：

1. **Cut**：**割 $(S, V-S)$** 是对 $V$ 的一个划分。
2. **Cross**：如果 $(u, v) \in E$， $u \in S, v\in V-S$，则称边 $(u, v)$ **通过割** $(S, V- S)$。
3. **Respect**：称一个 割(cut) **不妨害(respect)** 一个 边集 $A$， 如果对于任意 $(u, v) \in A \subseteq E$ 都不 **通过** 这个 cut。
4. **Light edge**：如果某个边的权值是通过一个割的所有边中最小的，则称该边为通过这个割的一条 **轻边（light edge）**（ 更一般的定义：如果一条边是 **满足某一性质** 的所有边中具有最小权值的边，则称该边为 **满足该性质的一条轻边**。）

**Lemma：设图 $G=(V, E)$ 是一个加权无向连通图， 和加权函数 $w: E \to R$。设 $A$ 是 $E$ 的一个子集，且$A$ 包含于 $G$ 的某个最小生成树。 设割 $(S, V-S)$ 是 $G$ 的任意一个不妨害 $A$的割（即 $A$ 中没有边通过割），且边$(u, v)$ 是通过割 $(S, V-S)$ 的一条轻边， 则边 $(u, v)$ 对集合 $A$ 来说是安全的。**

选择这样的安全边可以看做是一次贪心选择：可以扩张 $A$ 的具有最小权值的边。

可以用cut-paste方法证明贪心选择的边是安全的，贪心选择是某个最优解的一部分。

因此可以通过如下方式找到一条安全边：

1. 找到一个不妨害 $A$ 的割 (a cut respects A)
2. 找到一条轻边。

这个 **不妨害 respect** 实际上是一个很松的条件：割 $(S, V- S)$ respect  $A$，并没有限定 $S$ 必须刚好是边集 $A$ 的所有相关点。$V_A \subseteq S$。 但即使是这样，上面的结论也同样成立。 

直观的解释上面的定理： 把一个图 劈成两半时（割），通过两个部分的具有最小权值的边，一定是最小生成树的一条边。

当 选择 $S = V_A$ 的时候， 就是 Prim 算法。

如果把 集合 $A$ 看做一个森林，加入集合$A$ 中的安全边总是图中连接两个不同连通分支的最小权边。这是 Kruskal 算法。


### Prim 算法

Prim 算法核心思想：

1. 从任意一个点开始，做为树根
2. 如果没有取完所有的点，找到一条 **离开** 这棵树的最小权值的边， 加入这棵树。

更详细的步骤：

1. 选择任意点 $r$，  令 $S = \{r\}$， $A = \emptyset$
2. 找到一条通过 $(S, V - S)$ 的轻边，并加入 $A$，将另一个点加入 $S$。
3. 如果 $V - S = \emptyset$，最后得到一颗最小生成树 $(S, A)$。否则重复第二步。

更具体的问题：

1. 找轻边的方法？ 取最小值：优先级队列
2. 加边集 $A$ 的方法？对每条加入的边 $(u, v)$， 设置 `pred[v] = u`
3. 加点集 $S$ 的方法？使用染色标记 `color[v]`，初始都是白色的，添加到 $S$ 变成黑色的。


### Kruskal 算法

相比 Prim 算法， Kruskal算法更简明一些。

Kruskal算法用到了用于不相交集合的数据结构及操作。

具体思想：
1. 首先对每个顶点，初始化一个不相交集合。每个集合表示一棵树，所有集合构成初始的森林。
2. 对所有边按权重递增循序遍历：如果一条边是连接森林中两棵不同树（两个集合）的边，则 **同时也是一条轻边**。将这条边连接的集合进行 `UNION` 操作，合并成一个集合（树）。

注意在算法运行过程中，森林中的每棵树都是某个最小生成树的子集。添加一条连接两棵树的最小权值的边也不会破坏这个性质（可以通过cut-paste反证或者割的概念证明这一点）。最终通过 $|V| - 1$ 次连接操作，构成一棵最小生成树。

Kruskal 算法时间分析

1. 准备一个不相交集合数据结构 $O(V)$
2. 排序边集，$O(E\lg E)$
3. 对每条边 $(u, v)$： $O(E)$
    1. 判断是否在同一棵树中，`find(u) == find(v)`
    2. 如果不是，加入此边，`union(u, v)`

总的运行时间 为 $O(E\log V)$

```cpp
int mst_kruskal(Edge *edges, int m, int n)
{
    int i, j, k;
    int min_cost = 0;

    // vertices:  1...n
    DisjointSet dset = DisjointSet(n);

    // edges: 0...(m - 1)
    for (k = 0; k < m; ++k)
    {
        i = edges[k].u;
        j = edges[k].v;
        if (!dset.equivalent(i, j))
        {
            min_cost += edges[k].w;
            dset.unite(i, j);
        }
    }
    return min_cost;
}
```

需要注意每个点的编号和每条边的编号。 注意在MST 算法里主要是无向图。Kruskal 算法的一个小优点是不用存两条边。

Kruskal 算法的一个最大的优点，实际上是它的简明性：它清晰的指出了一个最小生成树通过不断添加可以添加的具有最小权值的边来生成。这一点比较重要。

### Prim 算法和 Dijkstra算法比较

《P3366》 MST 模板笔记。

Prim 存的是 (邻接点 和 边权)。 Dijkstra 存的是 (邻接点 和 最短路估计)。

Prim 需要明确的访问标记，用来判断访问的点是否在 $S = V_A$ 中；Dijkstra 需要一个最短路数组（也当访问标记用）。

Prim 也可以用所谓的 **堆优化** 的方式来提高效率。

普通的 Prim 仅使用标记访问数组，在取出的时候标记为已访问（参考 https://www.hackerearth.com/zh/practice/algorithms/graphs/minimum-spanning-tree/tutorial/ ）。 这样做有一个问题是，有些未访问的点可能被重复放进队列。这样是非常浪费的：凭空增加了队列的长度以及一些无用的操作。

一种策略类似于 Dijkstra 定义一个 **最短边数组**，初始化为 `INF`。 这个数组保存以每个顶点为终点的边的最小边权。 只有当发现一条边，并且边的终点没有被访问（意味着这条边通过割），并且边权比已知的边权小（最短边数组）的时候，才更新一下最短边数组，然后加入到优先级队列。 这样可以减少对一些大边的重复比较和计算，可以得到比较好的优化。

但是Prim 算法不可以像 Dijkstra 那样把标记访问数组给省略掉。 因为这个标记访问数组有一个非常重要的作用是定义割  $(V_A, V - V_A)$。 单纯用 **最短边数组** 是否达到最小来判定是否访问过是错误的。比如某一个点 b 连接三条边，边权分别为 $w(a1, b) = 1$，$w(a2, b) = 2$，$w(a3, b) = 3$。 如果从 $a3$ 出发的生成树，并且其他所有边权都大于 3， 会选择 $(a3, b)$ 加入 $A$，将 $b$ 加入 $S$，如果不做访问标记而是通过最短边比较，在未来某个时刻，会将 $(a1, b)$ 或者 $(a2, b)$ 加回到队列。这就构成了回路，这是错误的。

在 Dijkstra 算法中可以将标记访问数组省掉是因为，它是从某一点出发，对每个点的最短路估计进行松弛操作。它并不关心是否环回访问了某个点： 因为非负权路环回去也不可能比这个点的最短路更小，即使相等，这个点也只可能被松弛到最小一次，加入队列一次。这样就阻断了环路访问，就可以安全的省略掉访问标记数组。



经过优化后，Kruskal 和 Prim 算法都不用太考虑重边的情况。除非特殊情况必须要节省空间。 否则完全可以把所有边都加进去。
