

### 约瑟夫问题

据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。


参考 

- https://en.wikipedia.org/wiki/Josephus_problem
- https://www.geeksforgeeks.org/josephus-problem-set-1-a-on-solution/


#### 模拟约瑟夫问题输出

模拟输出似乎没有什么特别的好的手段。 $n$ 个人排成一排，挨个数数砍掉就是了。

在数据结构上可以这样模拟： 

```
12345...n12345...n12345...n12345
    |
0   i
```

想象 `i` 从 0 开始，就是增加（不用别的处理，认为序列是无穷长首尾相接的，模拟环）， `i` 对应的人的编号就是 `i % n + 1`

数数的话，另用一个变量 `j` 计数，活人计数 `j++`， 到 `j == m` 的时候，标记为杀掉就可以了。

算法时间复杂度为 $O(nm)$ 

```cpp
int main()
{
    const int MAX_N = 101;

    int n, m;
    int killed[MAX_N] = { false };

    cin >> n >> m;

    int i = 0, j = 0;  // i for pointer, j for counter of alive
    for (int k = 0; k < n; ++k)
    {
        for (j = 0; ; ++i)
            if (!killed[i % n])
                if (++j == m) break;

        cout << (i % n) + 1 << " ";
        killed[i++ % n] = true;
    }
    return 0;
}
```


#### 计算安全位置

参考 

- https://en.wikipedia.org/wiki/Josephus_problem


计算最后的安全位置不用模拟所有情况，可以用动态规划或者递归的方式解决问题。

令 $f(n, k)$ 为约瑟夫问题的最后安全位置。

```
12345...n12345...n12345...n12345
    |                  |
    k(k+1)...(n+k-1)   i
```

注意这里编号 $i$ 从 1开始， 则第 $i$ 个位置的 编号为 $(i - 1) \mod n + 1$

展开看： 在杀掉第 $k$ 个人之后， 从第 $k+1$ 个人到 第 $n + k - 1$ 个人构成一个 $n-1$ 个人的环。

如果以 $k + 1$ 为第一个人，且子问题的解为 $x = f(n - 1, k)$， 相当于偏离了 $k$ 位置 ，则 原问题 

$f(n , k) = (x + k - 1) \mod n + 1 = (f(n - 1, k) + k - 1) \mod n + 1$

并且有 $f(1, k) = 1$， 只有一个人的时候安全位置就是当前位置。

可以在 $O(n)$ 时间找出安全位置。


注意这种方法是递归找安全位置， 并不能模拟实际输出。

```cpp
int josephus(int n, int k)
{
  if (n == 1)
    return 1;
  else
    return (josephus(n - 1, k) + k-1) % n + 1;
}
```

