

## 背包问题 （Knapsack Problem）

参考： https://en.wikipedia.org/wiki/Knapsack_problem

背包问题属于在给定约束下的优化问题。

其一般形式为：

$$
\text{maximize}  \sum _{i=1}^{n}v_{i}x_{i} \\
\text{subject to} \sum _{i=1}^{n}w_{i}x_{i}\leq W  
$$

其中 $v_i$ 为每个物品的价值； $w_i$ 为每个物品的重量（一般认为是权重）。 $x_i$ 为物品的数量。

一般形式为： 最大化 $\sum_{i=1}^{n}v_{i}x_{i}$， 满足约束： $\sum_{i=1}^{n}w_{i}x_{i} \leq W$

三个具体形式：

1. 0-1背包问题： 每个物品要么拿，要么不拿， 即 $x_i \in \{0, 1\}$， 称为 0-1 背包问题。
2. 部分背包问题（fractional knapsack）： 物品可以无限分割，但数量有限： 即 $x_i \in \mathbb{R}, 0 \leq x_i \leq c_i$。
3. 0-$\infty$ 背包问题（又称完全背包问题）：每种物品有无限多个，可以重复拿， 即 $x_i \in \mathbb{N}$。

### 部分背包问题及贪心算法

部分背包问题可以用贪心算法解决： 每次取走尽可能多的单位重量价值最大的物品，直到填满整个背包。

**贪心选择的性质（Greedy Choice Property）**：令 $j$ 是具有最大 $v_i/w_i$ 的编号。 则存在一个最优解是取 **尽可能多的 $j$** 。

证明：

- 假设 有一个最优解是不用取那么多的 $j$。
- 如果背包没有满， 则继续添加一些 $j$，没毛病。 得到的方案居然一定以及肯定大于 最优解，矛盾。
- 所以假设背包是满的，则背包中必定存在某种物品 $k \neq j$，并且 $v_k / w_k < v_j / w_j$
- 因为还有一些 $j$ 没有添加，所以可以交换一些 $k$ 和 $j$， 这样会增加总价值
$$ \epsilon \frac{v_j}{w_j} - \epsilon \frac{v_k}{w_k} > 0 $$
居然又增加了总价值！！！矛盾。

贪心解和最优解具有相同的最优子结构， 所以贪心解可以得到最优解。


### 0-1 背包问题

0-1 背包问题不可以用贪心算法解决。

每次选最大价值的装，如果装不了其他的就尴尬了，或许存在另一种方案，小而多的拿，可以得到的价值更高。举个简单的例子 8，3，3，3， 背包容量为 10。 拿一个8，不如拿3个3。

0-1 背包问题可以用动态规划方法解决。

令 $dp(n, W)$ 为从前 $n$ 个物品中满足约束的最优解。 那么最优解只有两种可能性：

1. 包括第 $n$ 个物品： $dp(n - 1, W - w_n) + v_n$
2. 不包括第 $n$ 个物品： $dp(n - 1, W)$

从这两个中间选择一个最大值就是 $n$ 个物品的最优解。

算法时间复杂度为 $O(nW)$

可以压缩空间使用： $O(W)$，用一个一维数组保存结果。

注意在每个点  $dp(n, W)$ 上， 需要知道 $dp(n - 1, W)$ 的值和 $dp(n - 1, W - w_n)$ 的值。

如果画出来二维矩阵，可以发现，使用的是正上方的一个值，以及左上方的一个值。

所以用一个一维数组，每次从后向前更新数据就可以了。

```cpp
#include <cstdio>

int max(int a, int b) { return (a > b) ? a : b; }

int main()
{
    const int MAX_W = 1001;
    int n, W;
    scanf("%d %d", &W, &n);

    int vi, wi, i, w;
    int dp[MAX_W] = {0};
    for (i = 1; i <= n; ++i)
    {
        scanf("%d %d", &vi, &wi);
        for (w = W; w >= wi; --w)
            dp[w] = max(dp[w], dp[w - wi] + vi);
    }
    printf("%d", dp[W]);

    return 0;
}
```

物品选择范围为 1、2、3... n 的时候各更新一遍数组。 最后的 `m[n]` 即为最优解。


### Unbounded Knapsack（Repetition of items allowed）

0-1 背包还有一个变种，就是所有物品都是无限重复可选的。即 $x_i \in \mathbb{N}$

参考： https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/

令 $dp(n-1, w)$ 是从 $n-1$ 种物品中选择若干个，填充背包并且价值最大的最优解。

现在有一种新的物品 $n$，问 $dp(n, w)$ 是多少？

考虑两种情况：

- 不使用 $n$ 物品， $dp(n - 1, w)$
- 将其中的 $w_n$ 部分用 $n$ 物品取代（加入一件 $n$ 物品）， $dp(n, w - w_n) + v_n$

所以有 $dp(n, w) = \max(dp(n - 1, w), dp(n, w - w_n) + v_n)$。 

再回过头看看一般 0-1 背包问题的状态方程，二者放在一起比较一下。

- $dp(n, w) = \max (dp(n - 1, w), dp(n - 1, w - w_n) + v_n)$
- $dp(n, w) = \max(dp(n - 1, w), dp(n, w - w_n) + v_n)$。 

唯一的不一样的地方就是： 在最后一个 $dp$ 项中，用的是 $n$ 还是 $n-1$。

这是区分 0-1背包和 完全背包的关键点。 为什么完全背包是 $n$ 而不是 $n-1$ ？ 因为 在剩余的 $w - w_n$ 中也需要考虑进去 第$n$种物品的情况，第$n$ 种物品并不是在 $dp(n, w)$ 的时候第一次被考虑到。

这一点很难直观感觉到。但是把递归的所有分支画出来就比较好理解： 0件 $n$物品， 1件 $n$ 物品，2件 $n$ 物品，...，每种情况都有考虑，并且每种情况都只考虑了一次。

算法复杂度仍然是 $O(nW)$ ，其中 $n$ 是 **物品种类数** 而不是可选择物品的总数量。虽然物品有无限多个。

$dp(n, w)$ 依赖上一层的值，和同层前移 $w_n$ 的值。所以在压缩状态的时候，从前向后更新状态。


```cpp
int main()
{
    int W, n, w[MAX_N], v[MAX_N];
    int i, j;
    scanf("%d %d", &W, &n);
    for (j = 0; j < n; ++j)
        scanf("%d %d", &w[j], &v[j]);

    int dp[MAX_W] = {0};
    for (j = 0; j < n; ++j)
        for (i = w[j]; i <= W; ++i)
            dp[i] = max(dp[i], dp[i - w[j]] + v[j]);
    printf("%d", dp[W]);

    return 0;
}
```
差不多相同的代码，不过一个从前向后遍历，另一个从后向前遍历，两种截然不同的结果。


### 背包问题变形

#### AMAP, As More As Possible, $v=1$，在$W$ 限制下，选择最多的物品

在$v=1$ 的情况下，是可以用贪心算法解的。

先按照 $w$ 排序，小的在前，大的在后面。 从小的选起，直到累积的 $w$ 接近 $W$。

可以证明： 一般最优解可以通过交换变成贪心解：如果不是每次选择最小的，一定有一个$w$ 的比最优解中的某个 $w$ 小，两个互换也不改变最优解。最后可以得到贪心解。所以贪心解也是最优解。

比如洛谷上的 P2983 和 P1926。都可以用贪心算法解决。


#### 知足常乐：能够得到价值 $V$ 的最小 $w$

0-1 背包问题变形。

计算 $dp(n, w)$， 然后 $w \in [1, W]$ 中找到第一个大于等于 $V$ 的 $w$ ，即为得到价值$V$ 的最小 $w$。

#### 货币组合问题： 用一些基础数，组成一个数（一般是求和），问某个数的组合方案数。

完全背包问题： 考虑每个基础数都是无限个。

令 $dp(n, x)$ 表示用 $n$ 个基础数表示 $x$ 的组合方案数。

与完全背包的动规思路是一样的： $dp(n, x) = dp(n - 1, x) + dp(n, x - x_n)$

```cpp
#include <cstdio>

#define MAX_N 26
#define MAX_NUM 10001

int main()
{
    int n, num, i, j;
    scanf("%d %d", &n, &num);

    int a[MAX_N];   // base
    for (i = 0; i < n; ++i)
        scanf("%d", &a[i]);

    long long dp[MAX_NUM] = {0};
    dp[0] = 1;
    for (i = 0; i < n; ++i)
        for (j = a[i]; j <= num; ++j)
            dp[j] = dp[j] + dp[j - a[i]];

    printf("%lld", dp[num]);

    return 0;
}
```

#### 