

## 背包问题 （Knapsack Problem）

参考： https://en.wikipedia.org/wiki/Knapsack_problem

背包问题属于在给定约束下的优化问题。

其一般形式为：

$$
\text{maximize}  \sum _{i=1}^{n}v_{i}x_{i} \\
\text{subject to} \sum _{i=1}^{n}w_{i}x_{i}\leq W  
$$

其中 $v_i$ 为每个物品的价值； $w_i$ 为每个物品的重量（一般认为是权重）。 $x_i$ 为物品的数量。

一般形式为： 最大化 $\sum_{i=1}^{n}v_{i}x_{i}$， 满足约束： $\sum_{i=1}^{n}w_{i}x_{i} \leq W$

两个具体形式：

1. 0-1背包问题： 每个物品要么拿，要么不拿， 即 $x_i \in \{0, 1\}$， 称为 0-1 背包问题。
2. 部分背包问题（fractional knapsack）： 物品可以无限分割，但数量有限： 即 $x_i \in \mathbb{R}, 0 \leq x_i \leq c_i$。

### 部分背包问题及贪心算法

部分背包问题可以用贪心算法解决： 每次取走尽可能多的单位重量价值最大的物品，直到填满整个背包。

**贪心选择的性质（Greedy Choice Property）**：令 $j$ 是具有最大 $v_i/w_i$ 的编号。 则存在一个最优解是取 **尽可能多的 $j$** 。

证明：

- 假设 有一个最优解是不用取那么多的 $j$。
- 如果背包没有满， 则继续添加一些 $j$，没毛病。 得到的方案居然一定以及肯定大于 最优解，矛盾。
- 所以假设背包是满的，则背包中必定存在某种物品 $k \neq j$，并且 $v_k / w_k < v_j / w_j$
- 因为还有一些 $j$ 没有添加，所以可以交换一些 $k$ 和 $j$， 这样会增加总价值
$$ \epsilon \frac{v_j}{w_j} - \epsilon \frac{v_k}{w_k} > 0 $$
居然又增加了总价值！！！矛盾。

贪心解和最优解具有相同的最优子结构， 所以贪心解可以得到最优解。


### 0-1 背包问题

0-1 背包问题不可以用贪心算法解决。

每次选最大价值的装，如果装不了其他的就尴尬了，或许存在另一种方案，小而多的拿，可以得到的价值更高。举个简单的例子 8，3，3，3， 背包容量为 10。 拿一个8，不如拿3个3。

0-1 背包问题可以用动态规划方法解决。

令 $dp(n, W)$ 为从前 $n$ 个物品中满足约束的最优解。 那么最优解只有两种可能性：

1. 包括第 $n$ 个物品： $dp(n - 1, W - w_n) + v_n$
2. 不包括第 $n$ 个物品： $dp(n - 1, W)$

从这两个中间选择一个最大值就是 $n$ 个物品的最优解。

算法时间复杂度为 $O(nW)$


一种伪码是：

```cpp
// Input:
// Values (stored in array v)
// Weights (stored in array w)
// Number of distinct items (n)
// Knapsack capacity (W)
// NOTE: The array "v" and array "w" are assumed to store all relevant values starting at index 1.

// 初始化
for j from 0 to W do:
    m[0, j] := 0

for i from 1 to n do:
    for j from 0 to W do:
        if w[i] > j then:
            m[i, j] := m[i-1, j]
        else:
            m[i, j] := max(m[i-1, j], m[i-1, j-w[i]] + v[i])
```

可以压缩空间使用： $O(W)$，用一个一维数组保存结果。

注意在每个点  $dp(n, W)$ 上， 需要知道 $dp(n - 1, W)$ 的值和 $dp(n - 1, W - w_n)$ 的值。

如果画出来二维矩阵，可以发现，使用的是正上方的一个值，以及左上方的一个值。

所以用一个一维数组，每次从后向前更新数据就可以了。

```cpp
// 初始化
for j from 0 to W do:
    m[j] := 0

for i from 1 to n do:
    for j from W to 1 do:
        if j >= w[i] then:
            m[j] := max(m[j], m[j - w[i]] + v[i])
```

物品选择范围为 1、2、3... n 的时候各更新一遍数组。 最后的 `m[n]` 即为最优解。