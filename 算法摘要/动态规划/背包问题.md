

## 背包问题 （Knapsack Problem）

参考： https://en.wikipedia.org/wiki/Knapsack_problem

背包问题属于在给定约束下的优化问题。

其一般形式为：

$$
\text{maximize}  \sum _{i=1}^{n}v_{i}x_{i} \\
\text{subject to} \sum _{i=1}^{n}w_{i}x_{i}\leq W  
$$

其中 $v_i$ 为每个物品的价值； $w_i$ 为每个物品的重量（一般认为是权重）。 $x_i$ 为物品的数量。

一般形式为： 最大化 $\sum_{i=1}^{n}v_{i}x_{i}$， 满足约束： $\sum_{i=1}^{n}w_{i}x_{i} \leq W$

两个具体形式：

1. 0-1背包问题： 每个物品要么拿，要么不拿， 即 $x_i \in \{0, 1\}$， 称为 0-1 背包问题。
2. 部分背包问题（fractional knapsack）： 物品可以无限分割，但数量有限： 即 $x_i \in \mathbb{R}, 0 \leq x_i \leq c_i$。

### 部分背包问题及贪心算法

部分背包问题可以用贪心算法解决： 每次取走尽可能多的单位重量价值最大的物品，直到填满整个背包。

**贪心选择的性质（Greedy Choice Property）**：令 $j$ 是具有最大 $v_i/w_i$ 的编号。 则存在一个最优解是取 **尽可能多的 $j$** 。

证明：

- 假设 有一个最优解是不用取那么多的 $j$。
- 如果背包没有满， 则继续添加一些 $j$，没毛病。 得到的方案居然一定以及肯定大于 最优解，矛盾。
- 所以假设背包是满的，则背包中必定存在某种物品 $k \neq j$，并且 $v_k / w_k < v_j / w_j$
- 因为还有一些 $j$ 没有添加，所以可以交换一些 $k$ 和 $j$， 这样会增加总价值
$$ \epsilon \frac{v_j}{w_j} - \epsilon \frac{v_k}{w_k} > 0 $$
居然又增加了总价值！！！矛盾。

贪心解和最优解具有相同的最优子结构， 所以贪心解可以得到最优解。


### 0-1 背包问题

0-1 背包问题不可以用贪心算法解决。

每次选最大价值的装，如果装不了其他的就尴尬了，或许存在另一种方案，小而多的拿，可以得到的价值更高。举个简单的例子 8，3，3，3， 背包容量为 10。 拿一个8，不如拿3个3。

0-1 背包问题可以用动态规划方法解决。

令 $dp(n, W)$ 为从前 $n$ 个物品中满足约束的最优解。 那么最优解只有两种可能性：

1. 包括第 $n$ 个物品： $dp(n - 1, W - w_n) + v_n$
2. 不包括第 $n$ 个物品： $dp(n - 1, W)$

从这两个中间选择一个最大值就是 $n$ 个物品的最优解。

算法时间复杂度为 $O(nW)$


一种伪码是：

```cpp
// Input:
// Values (stored in array v)
// Weights (stored in array w)
// Number of distinct items (n)
// Knapsack capacity (W)
// NOTE: The array "v" and array "w" are assumed to store all relevant values starting at index 1.

// 初始化
for j from 0 to W do:
    m[0, j] := 0

for i from 1 to n do:
    for j from 0 to W do:
        if w[i] > j then:
            m[i, j] := m[i-1, j]
        else:
            m[i, j] := max(m[i-1, j], m[i-1, j-w[i]] + v[i])
```

可以压缩空间使用： $O(W)$，用一个一维数组保存结果。

注意在每个点  $dp(n, W)$ 上， 需要知道 $dp(n - 1, W)$ 的值和 $dp(n - 1, W - w_n)$ 的值。

如果画出来二维矩阵，可以发现，使用的是正上方的一个值，以及左上方的一个值。

所以用一个一维数组，每次从后向前更新数据就可以了。

```cpp
// 初始化
for j from 0 to W do:
    m[j] := 0

for i from 1 to n do:
    for j from W to 1 do:
        if j >= w[i] then:
            m[j] := max(m[j], m[j - w[i]] + v[i])
```

物品选择范围为 1、2、3... n 的时候各更新一遍数组。 最后的 `m[n]` 即为最优解。


### Unbounded Knapsack（Repetition of items allowed）

0-1 背包还有一个变种，就是所有物品都是无限重复可选的。即 $x_i \in \mathbb{N}$

参考： https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/

还是考虑 $dp(n, w)$ 这个状态函数。 这样考虑，在第 $n$ 次选择时： 

$$dp(n, w) = \max
\left\{ \begin{array}{ll}
dp(n - 1, w) & 不选 \\
dp(n - 1, w - w_1) + v_1  & 加入第1种物品 \\
dp(n - 1, w - w_2) + v_2  & 加入第2种物品 \\
\cdots \\
dp(n - 1, w - w_m) + v_m  & 加入第m种物品 \\
\end{array}\right.
$$

可以发现， $dp(n, w)$ 只与 $dp(n - 1, w')$ 有关， $w' \leq w$ 。并且这里 $dp(n, w)$ 中的 $n$ 似乎没有什么用。我们只关心 $dp(w)$， 不关心选择了多少次。

因此可以先求出 $dp(w)$， 然后继续计算 $dp(w + 1)$， 直到 $dp(W)$

算法复杂度为 $O(mW)$ ，其中 $m$ 是 **物品种类数** 而不是可选择物品的总数量。

```cpp
int unboundedKnapsack(int W, int n, int val[], int wt[])
{
    // dp[i] is going to store maximum value
    // with knapsack capacity i.
    int dp[W+1];
    memset(dp, 0, sizeof dp);
 
    int ans = 0;
 
    // Fill dp[] using above recursive formula
    for (int i=0; i<=W; i++)
      for (int j=0; j<n; j++)
         if (wt[j] <= i)
            dp[i] = max(dp[i], dp[i-wt[j]]+val[j]);
 
    return dp[W];
}
```

上面的思路还可以换个角度，可能更为直接： 令 $dp(m-1, w)$ 是从 $m-1$ 种物品中选择若干个，填充背包并且价值最大的最优解。

现在有一种新的物品 $m$， 问 $dp(m, w)$ 是多少？

其实这个状态方程也很容易看出来：

1. 当这个新物品不存在： $dp(m-1, w)$
2. 选一个吧： $dp(m-1, w - w_m) + v_m$
3. 选两个吧： $dp(m-1, w - 2w_m) + 2v_m$
4. ...
5. 直到 $w < kw_m$。

是相同的计算，但是内外循环互换了一下： 先从 1种物品开始，看所有最优解 $dp(1, w)$， 最后到第 $m$ 种物品，计算所有最优解 $dp(m, w)$。

```cpp
int main()
{
    int W, n, w[MAX_N], v[MAX_N];
    int i, j;
    scanf("%d %d", &W, &n);
    for (j = 0; j < n; ++j)
        scanf("%d %d", &w[j], &v[j]);

    int dp[MAX_W] = {0};
    for (j = 0; j < n; ++j)
        for (i = w[j]; i <= W; ++i)
            dp[i] = max(dp[i], dp[i - w[j]] + v[j]);
    printf("%d", dp[W]);

    return 0;
}
```

注意上面 `for (i = w[j]; i <= W; ++i)` ，我曾经想用 `for (i = w[j]; i <= W; i += w[j])`， 因为 就像上面分析的，取整数个 $m$ 物品。

其实这是不对的。正确的思路还要调转一下：

考虑一个新物品 $m$，

1. $dp(m, 1)$ ~ $dp(m, w_m - 1)$ 都不可能包括物品 $m$，所以不变；
2. $dp(m, w_m)$ 可以有 $m$ 了， 所以 $dp(m, w_m) = \max(dp(m, w_m), dp(m, 0) + v_m)$
3. $dp(m, w_m + 1)$ 也需要计算一下 $\max(dp(m, w_m), dp(m, 1) + v_m)$
4. 对任意的 $dp(m, w_m + x)$ 都需要更新一下： $\max{(dp(m, w_m + x), dp(m, x) + v_m)}$

这样从小到大的计算所有的 $dp(m, w)$。其实是从小到大更新的： 后面的值会依赖前面的值。
