
## 高精度

一般高精度指大整数， 比如 $10^{10000}$ 这种级别的数学运算，虽然这种数字没什么现实意义。
一般的数，长整型 （`long long`， $10^{18}$） 就够用了。

有两种表示方法：

1. 字符串表示： 这些数字都可以用 字符串表示。
2. `vector<int>` 表示： 可以分段、分进制计数。 

前者更容易写，出错率也低。后者虽然精巧，但是写起来出错率较高。

字符串表示可以参考 : https://github.com/panks/BigInteger/blob/master/BigIntegerSingleFile.cpp

vector 表示可以参考： https://github.com/kasparsklavins/bigint/tree/master/src

### 高精度加法


```cpp
string add(string num1, string num2)
{
    int l1 = num1.length(), l2 = num2.length();

    if (l1 > l2)
        num2.insert(0, l1 - l2, '0');
    else
        num1.insert(0, l2 - l1, '0');

    string sum = num1;
    char carry = 0;

    for (int i = sum.size() - 1; i >= 0; --i)
    {
        sum[i] += (carry + num2[i] - '0');
        if (sum[i] > '9')
        {
            sum[i] -= 10;
            carry = 1;
        }
        else
            carry = 0;
    }
    if (carry) sum.insert(0, 1, '1');
    return sum;
}
```

### 高精度减法

注意三件事情：

1. 对齐 padding
2. 比较大小，然后调换
3. 借位相减（注意虽然 `i` 最后为0，但是 `i-1 = -1` 不会发生，因为第2点的保障）

```cpp
string subtract(string num1, string num2)
{
    int l1 = num1.length(), l2 = num2.length();
    string sub = l1 > l2 ? num1 : num2;

    if (l1 > l2)
        num2.insert(0, l1 - l2, '0');
    else
        num1.insert(0, l2 - l1, '0'); // padding zeros
    
    bool negative = num1 < num2;
    if (negative) { string tmp = num1; num1 = num2; num2 = tmp; }

    for (int i = num1.length() - 1; i >= 0; --i)
    {
        if (num1[i] < num2[i])
        {
            num1[i] += 10;
            num1[i - 1]--;
        }
        sub[i] = ((num1[i] - '0') - (num2[i] - '0')) + '0';
    }
    while (sub[0] == '0' && sub.length() != 1) // erase leading zeros
        sub.erase(0, 1);
    
    if (negative) sub.insert(0, 1, '-');

    return sub;
}
```


### 高精度乘法

使用了加法运算。 高精度乘法用数组形式会更快一些： 先移位乘加， 最后再统一处理进位。

```cpp
string multiply(string n1, string n2)
{
    if (n1.length() > n2.length()) n1.swap(n2);
    int l1 = n1.length(), l2 = n2.length();  // l1 < l2

    string res = "0";
    // for every digit in n2, multiply short n1, then add
    for (int i = l1 - 1; i >= 0; --i)
    {
        string t = n2;
        int digit = n1[i] - '0';
        int carry = 0;

        for (int j = l2 - 1; j >= 0; --j)
        {
            t[j] = ((t[j] - '0') * digit) + carry;  // max 9 * 9 = 81
            if (t[j] > 9)
            {
                carry = (t[j] / 10);
                t[j] -= (carry * 10);
            }
            else
                carry = 0;
            t[j] += '0'; // back to string mood
        }

        if (carry > 0)
            t.insert(0, 1, (char)(carry + '0'));

        t.append(l1 - i - 1, '0'); // as like mult by 10, 100, 1000, 10000 and so on

        res = add(res, t);   // O(n)
    }

    while (res[0] == '0' && res.length() != 1) // erase leading zeros
        res.erase(0, 1);

    return res;
}
```



