

## 128位非负整型  `uint128_t`

抛开常用的通用的大整型数字， 有时候 128位整型或者非负整型也够用， 这里介绍 128 位整型的手写方式。

注意 C++里面有 `__int128` 可以用。

`uint128_t` 只使用两个 `uint64_t` 分别表示高 64位 和 低64位。

主要参考 ： https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp

### 构造

```cpp
class uint128_t
{
  private:
    uint64_t UPPER, LOWER;

  public:
    // constructor
    uint128_t(): UPPER(0), LOWER(0) {}
    uint128_t(uint64_t l): UPPER(0), LOWER(l) {}
    uint128_t(uint64_t h, uint64_t l): UPPER(h), LOWER(l) {}
  ...
}
```

### 加法操作

加法操作应该算是基本操作

```cpp
    uint128_t operator+(const uint128_t &rhs) const
    {
        return uint128_t(UPPER + rhs.UPPER + ((LOWER + rhs.LOWER) < LOWER),
                         LOWER + rhs.LOWER);
    }

    uint128_t &operator+=(const uint128_t &rhs)
    {
        *this = *this + rhs;
        return *this;
    }
```

### 移位操作

移位操作也很方便

```cpp
    uint128_t operator<<(const int &shift) const
    {
        if (shift < 0)
            return *this >> -shift;
        else if (shift == 0)
            return *this;
        else if (shift < 64)
            return uint128_t((UPPER << shift) + (LOWER >> (64 - shift)),
                             LOWER << shift);
        else if (shift == 64)
            return uint128_t(LOWER, 0);
        else if (shift < 128)
            return uint128_t(LOWER << (shift - 64), 0);
        else
            return uint128_t(0);
    }

    uint128_t & operator<<=(const int &shift)
    {
        *this = *this << shift; 
        return *this; 
    }

    uint128_t operator>>(const int &shift) const
    {
        if (shift < 0)
            return *this << -shift;
        else if (shift == 0)
            return *this;
        else if (shift < 64)
            return uint128_t(UPPER >> shift,
                             (UPPER << (64 - shift)) + (LOWER >> shift));
        else if (shift == 64)
            return uint128_t(0, UPPER);
        else if (shift < 128)
            return uint128_t(0, (UPPER >> (shift - 64)));
        else
            return uint128_t(0);
    }

    uint128_t & operator>>=(const int &shift)
    {
        *this = *this >> shift;
        return *this;
    }
```

注意这里我用的 `shift` 就是普通整型： 因为这个数字大了也没什么意义。位数是数的对数级别，一般比较小。

同时，如果 `shift` 是负数，则反向操作。


### divmod 运算

需要返回两个值：商和余数。这里我也是做了一下折中，没有写通用的除法。 主要是为了省事。

除数是一个 `uint32_t` 整型， 那么把 `uint128_t` 分成 4段 `uint64_t`， 每段先除 `base` ，余数左移 32位后和下一个段相加，再求商求余。 最后将商拼起来。

这里需要一个证明就是如果第一段的 $a_1 = q_1B + r_1$，那么下一段 $r_1 *2^{32} *B + a_2$ 不会超过 $B * 2^{32}$ （即表示商不会超过 $2^{32}$ 不会影响前一段）

这其实比较容易看出来： $r_1 \leq B - 1$，$a_2 < 2^{32}$。

```cpp
    pair<uint128_t, uint32_t> divmod(const uint32_t &divisor) const
    {
        if (divisor == 0)
            throw domain_error("Error: division or modulus by 0");
        else if (divisor == 1)
            return pair<uint128_t, uint32_t>(*this, 0);
        
        uint64_t q[4] = {UPPER >> 32, UPPER & 0xffffffff, LOWER >> 32, LOWER & 0xffffffff};
        uint64_t d, r = 0;
        for (int i = 0; i < 4; ++i)
        {
            d = (r << 32) + q[i];
            q[i] = d / divisor;
            r = d % divisor;
        }
        return pair<uint128_t, uint32_t>(uint128_t((q[0] << 32) | q[1], (q[2] << 32) | q[3]), (uint32_t)r);
    }
```

### 进制输出

有了 `divmod` 之后就非常简单： 除除除，余数变字符。下面代码是搬过来的，还不错。

```cpp
    operator bool() const { return (bool)(UPPER | LOWER); }
    bool operator!() const { return !(bool)(UPPER | LOWER); }

    string str(const uint32_t base = 10) const
    {
        if ((base < 2) || (base > 16))
            throw invalid_argument("Base must be in the range [2, 16]");
        
        if (!(*this)) return "0";
        string out = "";
        pair<uint128_t, uint32_t> qr(*this, 0);
        do
        {
            qr = qr.first.divmod(base);
            out = "0123456789abcdef"[qr.second] + out;
        } while (qr.first);
        return out;
    }
```

